syntax = "proto3";

package concordium.v2.plt;

// This specifies the package we want to use for our generated Go code.
// Has no effect on code generated on other languages.
option go_package = "./pb";

// This specifies the package we want to use for our generated Java classes.
// Has no effect on code generated on other languages.
option java_package = "com.concordium.grpc.v2.plt";

// This specifies that separate .java files will be generated for each of the Java classes/enums/etc. generated for the top-level messages, services, and enumerations,
// and the wrapper Java class generated for this .proto file won't contain any nested classes/enums/etc.
// If not generating Java code, this option has no effect.
option java_multiple_files = true;

// This specifies the package we want to use for our generated C# classes.
// Has no effect on code generated on other languages.
option csharp_namespace = "Concordium.Grpc.V2.Plt";

import "v2/concordium/kernel.proto";

// A Cbor encoded bytestring
message CBor {
  // A CBOR encoded byte string.
  bytes value = 1;
}

// The unique symbol and identifier of a protocol level token.
message TokenId {
  // Unique identifier for the token, guaranteed to be distinct across the
  // entire concordium blockchain.
  string symbol = 1;
}

// A token module reference. This is always 32 bytes long.
message TokenModuleRef {
  bytes value = 1;
}

// PLT amount representation. The actual amount is computed as `digits *
// 10^(-nr_of_decimals)`.
message TokenAmount {
  // The digits of the amount.
  uint64 digits = 1;
  // Number of decimals in the representation
  uint32 nr_of_decimals = 2;
}

// Token state at the block level
message TokenState {
  // The reference of the module implementing this token.
  TokenModuleRef token_module_ref = 1;
  // Account address of the issuer. The issuer is the holder of the nominated
  // account which can perform token-governance operations.
  concordium.v2.AccountAddress issuer = 2;
  // Number of decimals in the decimal number representation of amounts.
  uint32 nr_of_decimals = 3;
  // The total available token supply.
  TokenAmount total_supply = 4;
  // Token module specific state, such as token name, feature flags, meta data.
  CBor module_state = 5;
}

// Token state at the account level
message TokenAccountState {
  // The available balance.
  TokenAmount balance = 1;
  // Whether the account is a member of the allow list of the token.
  // If present, tokens can be transferred only, if both sender and receiver are
  // members of the allow list of the token.
  optional bool member_allow_list = 2;
  // Whether the account is a member of the deny list of the token.
  // If present, tokens can be transferred only, if neither sender or receiver
  // are members of the deny list.
  optional bool member_deny_list = 3;
}

// Single token event originating from a token module as part of a token
// transaction.
message TokenModuleEvent {
  // The type of the event.
  string type = 1;
  // The CBOR encoded event details.
  CBor details = 2;
}

// A token holder is an entity that can hold tokens. Currently, this is limited
// to accounts, but in the future it may be extended to other entities.
message TokenHolder {
  // The holder address
  oneof address {
    // The account address of the holder.
    AccountAddress account = 1;
  }
}

// An event emitted when a transfer of tokens from `from` to `to` is performed.
message TokenTransferEvent {
  // The token holder from which the tokens are transferred.
  TokenHolder from = 1;
  // The token holder to which the tokens are transferred.
  TokenHolder to = 2;
  // The amount of tokens transferred.
  TokenAmount amount = 3;
  // An optional memo field that can be used to attach a message to the token
  // transfer.
  optional Memo memo = 4;
}

// An event emitted when the token supply is updated, i.e. by minting/burning
// tokens to/from the balance of the `target`.
message TokenSupplyUpdateEvent {
  // The token holder the balance update is performed on.
  TokenHolder target = 1;
  // The balance difference to be applied to the target.
  TokenAmount amount = 2;
}

// Token events originating from token holder transactions.
message TokenHolderEvent {
  // The unique token symbol.
  TokenId token_symbol = 1;
  // The type of the event.
  oneof event {
    // An event emitted by the token module.
    TokenModuleEvent module_event = 1;
    // An event emitted when a transfer of tokens is performed.
    TokenTransferEvent transfer_event = 2;
  }
}

// Token events originating from token governance transactions.
message TokenGovernanceEvent {
  // The unique token symbol.
  TokenId token_symbol = 1;
  // The type of the event.
  oneof event {
    // An event emitted by the token module.
    TokenModuleEvent module_event = 1;
    // An event emitted when a transfer of tokens is performed.
    TokenTransferEvent transfer_event = 2;
    // An event emitted when the token supply is updated by minting tokens to a
    // token holder.
    TokenSupplyUpdateEvent mint_event = 3;
    // An event emitted when the token supply is updated by burning tokens from
    // the balance of a token holder.
    TokenSupplyUpdateEvent burn_event = 4;
  }
}

// Token events originating from token governance transactions.
message TokenGovernanceEffect {
  // Events emitted by the token.
  repeated TokenGovernanceEvent events = 1;
}

// Token events originating from token holder transactions.
message TokenHolderEffect {
  // Events emitted by the token.
  repeated TokenHolderEvent events = 1;
}

// Details provided by the token module in the event of rejecting a transaction.
message TokenModuleRejectReason {
    // The token symbol.
    TokenId token_symbol = 1;
    // The type of the reject reason.
    string type = 2;
    // (Optional) CBOR-encoded details.
    optional CBor details = 3;
}

// Update payload for creating a new protocol-level token
message CreatePLT {
    // The token symbol.
    TokenId token_symbol = 1;
    // The hash that identifies the token module implementation.
    TokenModuleRef token_module = 2;
    // The address of the account that will govern the token.
    AccountAddress governance_account = 3;
    // The number of decimal places used in the representation of amounts of this token.
    // This determines the smallest representable fraction of the token.
    // This can be at most 255.
    uint32 decimals = 4;
    // The initialization parameters of the token, encoded in CBOR.
    CBor initialization_parameters = 5;
}