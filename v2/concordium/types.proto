syntax = "proto3";

package concordium.v2;

// A message that contains no information.
message Empty {
}

// Hash of a block. This is always 32 bytes long.
message BlockHash {
  bytes value = 1;
}

// Hash of a transaction. This is always 32 bytes long.
message TransactionHash {
  bytes value = 1;
}

// Hash of the state after some block. This is always 32 bytes long.
message StateHash {
  bytes value = 1;
}

// The absolute height of a block. This is the number of ancestors of a block
// since the genesis block. In particular, the chain genesis block has absolute
// height 0.
message AbsoluteBlockHeight {
  uint64 value = 1;
}

// The height of a block relative to the last genesis. This differs from the
// absolute block height in that it counts height from the last protocol update.
message BlockHeight {
  uint64 value = 1;
}

// The ID of a baker, which is the index of its account.
message BakerId {
  uint64 value = 1;
}

// Index of the account in the account table. These are assigned sequentially
// in the order of creation of accounts. The first account has index 0.
message AccountIndex {
  uint64 value = 1;
}

// A smart contract module reference. This is always 32 bytes long.
message ModuleRef {
  bytes value = 1;
}

// Source bytes of a versioned smart contract module.
message VersionedModuleSource {
  // Source bytes of a smart contract v0 module.
  message ModuleSourceV0 {
    bytes value = 1;
  }

  // Source bytes of a smart contract v1 module.
  message ModuleSourceV1 {
    bytes value = 1;
  }

  oneof module {
    ModuleSourceV0 v0 = 1;
    ModuleSourceV1 v1 = 2;
  }
}

// Unix timestamp in milliseconds.
message Timestamp {
  uint64 value = 1;
}

// An individual release of a locked balance.
message Release {
  // Effective time of the release in milliseconds since unix epoch.
  Timestamp timestamp = 1;
  // Amount to be released.
  Amount amount = 2;
  // List of transaction hashes that contribute a balance to this release.
  repeated TransactionHash transactions = 3;
}

// State of the account's release schedule. This is the balance of the account
// that is owned by the account, but cannot be used until the release point.
message ReleaseSchedule {
  // Total amount locked in the release schedule.
  Amount total = 1;
  // A list of releases, ordered by increasing timestamp.
  repeated Release schedules = 2;
}

// An encrypted amount, in two chunks in "little endian limbs". That is, the
// first chunk represents the low 32 bits of an amount, and the second chunk
// represents the high 32 bits. The chunks are serialized in order and
// represented as a byte array.
// Always 192 bytes.
message EncryptedAmount {
  bytes value = 1;
}

message EncryptedBalance {
  // Encrypted amount that is a result of this account's actions.
  // In particular this list includes the aggregate of
  //
  // - remaining amounts that result when transferring to public balance
  // - remaining amounts when transferring to another account
  // - encrypted amounts that are transferred from public balance
  //
  // When a transfer is made all of these must always be used.
  EncryptedAmount self_amount = 1;
  // Starting index for incoming encrypted amounts. If an aggregated amount
  // is present then this index is associated with such an amount and the
  // list of incoming encrypted amounts starts at the index `start_index
  // + 1`.
  uint64 start_index = 2;
  // If present, the amount that has resulted from aggregating other amounts
  // If this field is present so is `num_aggregated`.
  optional EncryptedAmount aggregated_amount = 3;
  // The number of aggregated amounts (must be at least 2 if present). This
  // field is present if and only if `aggregated_amount` is present.
  optional uint32 num_aggregated = 4;
  // Amounts starting at `start_index` (or at `start_index + 1` if there is
  // an aggregated amount present). They are assumed to be numbered
  // sequentially. The length of this list is bounded by the maximum number
  // of incoming amounts on the accounts, which is currently 32. After
  // that aggregation kicks in.
  repeated EncryptedAmount incoming_amounts = 5;
}

// Entity to which the account delegates a portion of its stake.
message DelegationTarget {
  oneof target {
    // Delegate passively, i.e., to no specific baker.
    Empty passive = 1;
    // Delegate to a specific baker.
    BakerId baker = 2;
  }
}

// Baker's public key used to check whether they won the lottery or not.
message BakerElectionVerifyKey {
  bytes value = 1;
}

// Baker's public key used to check that they are indeed the ones who
// produced the block.
message BakerSignatureVerifyKey {
  bytes value = 1;
}

// Baker's public key used to check signatures on finalization records.
// This is only used if the baker has sufficient stake to participate in
// finalization.
message BakerAggregationVerifyKey {
  bytes value = 1;
}

/// Information about a baker.
message BakerInfo {
  // Identity of the baker. This is actually the account index of
  // the account controlling the baker.
  BakerId baker_id = 1;
  // Baker's public key used to check whether they won the lottery or not.
  BakerElectionVerifyKey election_key = 2;
  // Baker's public key used to check that they are indeed the ones who
  // produced the block.
  BakerSignatureVerifyKey signature_key = 3;
  // Baker's public key used to check signatures on finalization records.
  // This is only used if the baker has sufficient stake to participate in
  // finalization.
  BakerAggregationVerifyKey aggregation_key = 4;
}

// Pending change to the stake either of a baker or delegator.
message StakePendingChange {
  message Reduce {
    Amount new_stake = 1;
    // Unix timestamp in milliseconds when the change takes effect.
    Timestamp effective_time = 2;
  }
  
  oneof change {
    Reduce reduce = 1;
    // Remove the stake. The value is a Unix timestamp of the effective time in
    // milliseconds.
    Timestamp remove = 2;
  }
}

// Information about how open the pool is to new delegators.
enum OpenStatus {
  OPEN_STATUS_OPEN_FOR_ALL = 0;
  OPEN_STATUS_CLOSED_FOR_NEW = 1;
  OPEN_STATUS_CLOSED_FOR_ALL = 2;
}

// A fraction of an amount with a precision of `1/100_000`.
message AmountFraction {
  // Must not exceed 100000.
  uint32 parts_per_hundred_thousand = 1;
}

// Distribution of the rewards for the particular pool.
message CommissionRates {
  // Fraction of finalization rewards charged by the pool owner.
  AmountFraction finalization = 1;
  // Fraction of baking rewards charged by the pool owner.
  AmountFraction baking = 2;
  // Fraction of transaction rewards charged by the pool owner.
  AmountFraction transaction = 3;
}

// Additional information about a baking pool.
// This information is added with the introduction of delegation.
message BakerPoolInfo {
  // Whether the pool allows delegators.
  OpenStatus open_status = 1;
  // The URL that links to the metadata about the pool.
  string url = 2;
  // The commission rates charged by the pool owner.
  CommissionRates commission_rates = 3;
}

// Information about the account stake, if the account is either a baker or a
// delegator.
message AccountStakingInfo {
  message Baker {
    // Amount staked at present.
    Amount staked_amount = 1;
    // A flag indicating whether rewards paid to the baker are automatically
    // restaked or not.
    bool restake_earnings = 2;
    // Information about the baker that is staking.
    BakerInfo baker_info = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
    // Present if the account is currently a baker, i.e., it is in the baking
    // committee of the current epoch.
    optional BakerPoolInfo pool_info = 5;
  }

  message Delegator {
    // The amount that the account delegates.
    Amount staked_amount = 1;
    // Whether the earnings are automatically added to the staked amount.
    bool restake_earnings = 2;
    // The entity to which the account delegates.
    DelegationTarget target = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
  }

  oneof staking_info {
    // The account is a baker.
    Baker baker = 1;
    // The account is a delegator.
    Delegator delegator = 2;
  }
}

// A sequence number that determines the ordering of transactions from the
// account. The minimum sequence number is 1.
message SequenceNumber {
  // The nonce
  uint64 value = 1;
}

// An amount of microCCD.
message Amount {
  uint64 value = 1;
}

// Index of a credential on an account.
message CredentialIndex {
  uint32 value = 1;
}

// The number of signatures required to sign.
message SignatureThreshold {
  uint32 value = 1;
}

// The number of credentials required to sign an account transaction.
message AccountThreshold {
  uint32 value = 1;
}

// An account encryption key. Always 96 bytes.
message EncryptionKey {
  bytes value = 1;
}

// An address of an account. Always 32 bytes.
message AccountAddress {
  bytes value = 1;
}

// An address of either a contract or an account.
message Address {
  oneof type {
    AccountAddress account = 1;
    ContractAddress contract = 2;
  }
}

// A public key used to verify transaction signatures from an account.
message AccountVerifyKey {
  oneof key {
    bytes ed25519_key = 1;
  }
}

// Public keys of a single credential.
message CredentialPublicKeys {
  map<uint32, AccountVerifyKey> keys = 1;
  SignatureThreshold threshold = 2;
}

// A registration ID of a credential, derived from the secret PRF key and a
// nonce. This is always 48 bytes long.
message CredentialRegistrationId {
  bytes value = 1;
}

// An index of the identity provider that identifies them uniquely in the
// context of a specific chain.
message IdentityProviderIdentity {
  uint32 value = 1;
}

// Representation of the pair of a year and month.
message YearMonth {
  uint32 year = 1;
  uint32 month = 2;
}

// Policy on a credential.
message Policy {
  // The year and month when the identity object from which the credential is
  // derived was created.
  YearMonth created_at = 1;
  // The last year and month when the credential is still valid. After this
  // expires an account can no longer be created from the credential.
  YearMonth valid_to = 2;
  // Mapping from attribute tags to attribute values. Attribute tags are always
  // representable in a single `u8`, attribute values are never more than 31
  // bytes in length.
  map<uint32, bytes> attributes = 3;
}

// Values contained in an initial credential.
message InitialCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
}

/// Data relating to a single anonymity revoker sent by the account holder to
/// the chain.
message ChainArData {
  // Share of the encryption of IdCredPub.
  bytes enc_id_cred_pub_share = 1;
}

// The number of anonymity revokers needed to revoke anonymity of a credential
// holder.
message ArThreshold {
  uint32 value = 1;
}

// A single commitment in the G1 group of the BLS curve. This is always 48 bytes
// in length.
message Commitment {
  bytes value = 1;
}

// Commitments that are part of a normal credential.
message CredentialCommitments {
  // Commitment to the PRF key.
  Commitment prf = 1;
  // Commitment to the counter used to generate the credential registration id.
  Commitment cred_counter = 2;
  // Commitment to the `max_accounts` value, which determines the maximum number
  // of credentials that may be created from the identity object.
  Commitment max_accounts = 3;
  // Commitments to the attributes which have not been revealed in the policy.
  map<uint32, Commitment> attributes = 4;
  // List of commitments to the coefficients of the sharing polynomial. This
  // polynomial is used in a shared encryption of `id_cred_pub` among the
  // anonymity revokers.
  repeated Commitment id_cred_sec_sharing_coeff = 5;
}

// Values contained in a normal (non-initial) credential.
message NormalCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
  // The number of anonymity revokers that must work together to revoke the
  // anonymity of the credential holder.
  ArThreshold ar_threshold = 5;
  // Mapping from anonymity revoker identities to revocation data for the given anonymity revoker.
  map<uint32, ChainArData> ar_data = 6;
  // Commitments to attributes which have not been revealed.
  CredentialCommitments commitments = 7;
}

// Credential that is part of an account.
message AccountCredential {
  oneof credential_values {
    InitialCredentialValues initial = 1;
    NormalCredentialValues normal = 2;
  }
}

// Information about the account at a particular point in time.
message AccountInfo {
  // Next sequence number to be used for transactions signed from this account.
  SequenceNumber sequence_number = 1;
  // Current (unencrypted) balance of the account.
  Amount amount = 2;
  // Release schedule for any locked up amount. This could be an empty
  // release schedule.
  ReleaseSchedule schedule = 3;
  // Map of all currently active credentials on the account.
  // This includes public keys that can sign for the given credentials, as
  // well as any revealed attributes. This map always contains a credential
  // with index 0.
  map<uint32, AccountCredential> creds = 4;
  // Lower bound on how many credentials must sign any given transaction from
  // this account.
  AccountThreshold threshold = 5;
  // The encrypted balance of the account.
  EncryptedBalance encrypted_balance = 6;
  // The public key for sending encrypted balances to the account.
  EncryptionKey encryption_key = 7;
  // Internal index of the account. Accounts on the chain get sequential
  // indices. These should generally not be used outside of the chain,
  // the account address is meant to be used to refer to accounts,
  // however the account index serves the role of the baker id, if the
  // account is a baker. Hence it is exposed here as well.
  AccountIndex index = 8;
  // Present if the account is a baker or delegator. In that case
  // it is the information about the baker or delegator.
  optional AccountStakingInfo stake = 9;
  // Canonical address of the account. This is derived from the first credential
  // that created the account.
  AccountAddress address = 10;
}

// Input to queries which take a block as a parameter.
message BlockHashInput {
  oneof block_hash_input {
    // Query for the best block.
    Empty best = 1;
    // Query for the last finalized block.
    Empty last_final = 2;
    // Query for the block specified by the hash. This hash should always be 32 bytes.
    BlockHash given = 3;
  }
}

// Input to queries which take an account as a parameter.
message AccountIdentifierInput {
  oneof account_identifier_input {
    // Identify the account by the address of the account.
    AccountAddress address = 1;
    // Identify the account by the credential that belongs or has belonged to it.
    CredentialRegistrationId cred_id = 2;
    // Identify the account via its index.
    AccountIndex account_index = 3;
  }
}

// Request for account information.
message AccountInfoRequest {
  // Block in which to query the account information.
  BlockHashInput block_hash = 1;
  // Specification of the account.
  AccountIdentifierInput account_identifier = 2;
}

// Information about a finalized block that is part of the streaming response.
message FinalizedBlockInfo {
  // Hash of the block.
  BlockHash hash = 1;
  // Absolute height of the block, height 0 is the genesis block.
  AbsoluteBlockHeight height = 2;
}

// Request the ancestors for the given block.
message AncestorsRequest {
  // The block to get ancestors of.
  BlockHashInput block_hash = 1;
  // The maximum number of ancestors returned.
  uint64 amount = 2;
}

// Request for getting the source of a smart contract module.
message ModuleSourceRequest {
  // The block to be used for the query.
  BlockHashInput block_hash = 1;
  // The reference of the module.
  ModuleRef module_ref = 2;
}

// Address of a smart contract instance.
message ContractAddress {
  // The index of the smart contract.
  uint64 index = 1;
  // The subindex of the smart contract instance.
  // Currently not used, so it is always 0.
  uint64 subindex = 2;
}

// Request for getting information about a smart contract instance.
message InstanceInfoRequest {
  // The block to be used for the query.
  BlockHashInput block_hash = 1;
  // The address of the smart contract instance.
  ContractAddress address = 2;
}

// Information about a smart contract instance.
message InstanceInfo {

  // Version 0 smart contract instance information.
  message V0 {
    // The state of the instance.
    ContractStateV0 model = 1;
    // The account address which deployed the instance.
    AccountAddress owner = 2;
    // The amount of CCD tokens in the balance of the instance.
    Amount amount = 3;
    // A list of endpoints exposed by the instance.
    repeated ReceiveName methods = 4;
    // The name of the smart contract of the instance.
    InitName name = 5;
    // The module reference for the smart contract module of the instance.
    ModuleRef source_module = 6;
  }

  // Version 1 smart contract instance information.
  message V1 {
    // The account address which deployed the instance.
    AccountAddress owner = 2;
    // The amount of CCD tokens in the balance of the instance.
    Amount amount = 3;
    // A list of endpoints exposed by the instance.
    repeated ReceiveName methods = 4;
    // The name of the smart contract of the instance.
    InitName name = 5;
    // The module reference for the smart contract module of the instance.
    ModuleRef source_module = 6;
  }

  // The information depends on the smart contract version used by the instance.
  oneof version {
    V0 v0 = 1;
    V1 v1 = 2;
  }
}

// The receive name of a smart contract function. Expected format: "<contract_name>.<func_name>".
// It must only consist of atmost 100 ASCII alphanumeric or punctuation characters, and must contain a '.'.
message ReceiveName {
  string value = 1;
}

// The init name of a smart contract function. Expected format: "init_<contract_name>".
// It must only consist of atmost 100 ASCII alphanumeric or punctuation characters, must not contain a '.' and must start with 'init_'.
message InitName {
  string value = 1;
}

// A smart contract v0 state.
message ContractStateV0 {
  bytes value = 1;
}

// Energy is used to count exact execution cost.
// This cost is then converted to CCD amounts.
message Energy {
  uint64 value = 1;
}

// A number representing a slot for baking a block.
message Slot {
  uint64 value = 1;
}

// The response for getNextAccountSequenceNumber.
message NextAccountSequenceNumber {
  // The best guess for the available account sequence number.
  SequenceNumber sequence_number = 1;
  // Whether the guess relies on any non-finalized transactions. If true all of the relevant transactions are finalized.
  bool all_final = 2;
}

// A duration of milliseconds.
message Duration {
  uint64 value = 1;
}

// The different versions of the protocol.
enum ProtocolVersion {
  PROTOCOL_VERSION_1 = 0;
  PROTOCOL_VERSION_2 = 1;
  PROTOCOL_VERSION_3 = 2;
  PROTOCOL_VERSION_4 = 3;
}

// The number of chain restarts via a protocol update. An effected
// protocol update instruction might not change the protocol version
// specified in the previous field, but it always increments the genesis
// index.
message GenesisIndex {
  uint32 value = 1;
}

// The response for GetConsensusInfo.
message ConsensusInfo {
  // Hash of the current best block.
  BlockHash best_block = 1;
  // Hash of the (original) genesis block.
  BlockHash genesis_block = 2;
  // Time of the (original) genesis block.
  Timestamp genesis_time = 3;
  // (Current) slot duration in milliseconds.
  Duration slot_duration = 4;
  // (Current) epoch duration in milliseconds.
  Duration epoch_duration = 5;
  // Hash of the last finalized block.
  BlockHash last_finalized_block = 6;
  // Absolute height of the best block.
  AbsoluteBlockHeight best_block_height = 7;
  // Absolute height of the last finalized block.
  AbsoluteBlockHeight last_finalized_block_height = 8;
  // Total number of blocks received.
  uint32 blocks_received_count = 9;
  // The last time a block was received.
  optional Timestamp block_last_received_time = 10;
  // Exponential moving average latency between a block's slot time and received time.
  double block_receive_latency_ema = 11;
  // Standard deviation of exponential moving average latency between a block's slot time and received time.
  double block_receive_latency_emsd = 12;
  // Exponential moving average time between receiving blocks.
  optional double block_receive_period_ema = 13;
  // Standard deviation of exponential moving average time between receiving blocks.
  optional double block_receive_period_emsd = 14;
  // Total number of blocks received and verified.
  uint32 blocks_verified_count = 15;
  // The last time a block was verified (added to the tree).
  optional Timestamp block_last_arrived_time = 16;
  // Exponential moving average latency between a block's slot time and its arrival.
  double block_arrive_latency_ema = 17;
  // Standard deviation of exponential moving average latency between a block's slot time and its arrival.
  double block_arrive_latency_emsd = 18;
  // Exponential moving average time between block arrivals.
  optional double block_arrive_period_ema = 19;
  // Standard deviation of exponential moving average time between block arrivals.
  optional double block_arrive_period_emsd = 20;
  // Exponential moving average number of transactions per block.
  double transactions_per_block_ema = 21;
  // Standard deviation of exponential moving average number of transactions per block.
  double transactions_per_block_emsd = 22;
  // Number of finalizations.
  uint32 finalization_count = 23;
  // Time of last verified finalization.
  optional Timestamp last_finalized_time = 24;
  // Exponential moving average time between finalizations.
  optional double finalization_period_ema = 25;
  // Standard deviation of exponential moving average time between finalizations.
  optional double finalization_period_emsd = 26;
  // Currently active protocol version.
  ProtocolVersion protocol_version = 27;
  // The number of chain restarts via a protocol update. A completed
  // protocol update instruction might not change the protocol version
  // specified in the previous field, but it always increments the genesis
  // index.
  GenesisIndex genesis_index = 28;
  // Block hash of the genesis block of current era, i.e., since the last protocol update.
  // Initially this is equal to 'genesis_block'.
  BlockHash current_era_genesis_block = 29;
  // Time when the current era started.
  Timestamp current_era_genesis_time = 30;
}

// Information about an arrived block that is part of the streaming response.
message ArrivedBlockInfo {
  // Hash of the block.
  BlockHash hash = 1;
  // Absolute height of the block, height 0 is the genesis block.
  AbsoluteBlockHeight height = 2;
}

// The response for GetCryptographicParameters.
message CryptographicParameters {
  // A free-form string used to distinguish between different chains even if they share other parameters.
  string genesis_string = 1;
  // Generators for the bulletproofs.
  bytes bulletproof_generators = 2;
  // A shared commitment key known to the chain and the account holder (and therefore it is public).
  // The account holder uses this commitment key to generate commitments to values in the attribute list.
  bytes on_chain_commitment_key = 3;
}

// The response for GetBlockInfo.
message BlockInfo {
  // Hash of the block.
  BlockHash hash = 1;
  // Absolute height of the block, height 0 is the genesis block.
  AbsoluteBlockHeight height = 2;
  // The parent block hash. For a re-genesis block, this will be the terminal block of the
  // previous chain. For the initial genesis block, this will be the hash of the block itself.
  BlockHash parent_block = 3;
  // The last finalized block when this block was baked.
  BlockHash last_finalized_block = 4;
  // The genesis index for this block. This counts the number of protocol updates that have
  // preceded this block, and defines the era of the block.
  GenesisIndex genesis_index = 5;
  // The height of this block relative to the (re)genesis block of its era.
  BlockHeight era_block_height = 6;
  // The time the block was received.
  Timestamp receive_time = 7;
  // The time the block was verified.
  Timestamp arrive_time = 8;
  // The slot number in which the block was baked.
  Slot slot_number = 9;
  // The time of the slot in which the block was baked.
  Timestamp slot_time = 10;
  // The baker id of account baking this block. Not provided for a genesis block.
  optional BakerId baker = 11;
  // Whether the block is finalized.
  bool finalized = 12;
  // The number of transactions in the block.
  uint32 transaction_count = 13;
  // The energy cost of the transactions in the block.
  Energy transactions_energy_cost = 14;
  // The total byte size of all transactions in the block.
  uint32 transactions_size = 15;
  // The hash of the block state after this block.
  StateHash state_hash = 16;
}
