syntax = "proto3";

package concordium.v2;

// A message that contains no information.
message Empty {
}

/// Hash of a block. This is always 32 bytes long.
message BlockHash {
  bytes value = 1;
}

/// Hash of a transaction. This is always 32 bytes long.
message TransactionHash {
  bytes value = 1;
}

// The absolute height of a block.
message AbsoluteBlockHeight {
  uint64 value = 1;
}

// The height of a block relative to the last genesis.
message BlockHeight {
  uint64 value = 1;
}

// The ID of a baker, which is the index of its account.
message BakerId {
  uint64 value = 1;
}

// Index of the account in the account table. These are assigned sequentially
// in the order of creation of accounts. The first account has index 0.
message AccountIndex {
  uint64 value = 1;
}

// Reference (hash) of a smart contract module. This is always 32 bytes long.
message ModuleRef {
  bytes value = 1;
}

//! Source bytes of a smart contract module.
// ok test
message ModuleSource {
  bytes value = 1;
}

// An individual release of a locked balance.
message Release {
  // Effective time of the release in milliseconds since unix epoch.
  uint64 timestamp = 1;
  // Amount to be released.
  Amount amount = 2;
  // List of transaction hashes that contribute a balance to this release.
  repeated TransactionHash transactions = 3;
}

// State of the account's release schedule. This is the balance of the account
// that is owned by the account, but cannot be used until the release point.
message ReleaseSchedule {
  Amount total = 1;
  repeated Release schedules = 2;
}

// An encrypted amount, in two chunks in "little endian limbs". That is, the
// first chunk represents the low 32 bits of an amount, and the second chunk
// represents the high 32 bits. The chunks are serialized in order and
// represented as a byte array.
// Always 192 bytes.
message EncryptedAmount {
  bytes value = 1;
}

message EncryptedBalance {
  // Encrypted amount that is a result of this accounts' actions.
  // In particular this list includes the aggregate of
  //
  // - remaining amounts that result when transfering to public balance
  // - remaining amounts when transfering to another account
  // - encrypted amounts that are transferred from public balance
  //
  // When a transfer is made all of these must always be used.
  EncryptedAmount self_amount = 1;
  // Starting index for incoming encrypted amounts. If an aggregated amount
  // is present then this index is associated with such an amount and the
  // list of incoming encrypted amounts starts at the index `start_index
  // + 1`.
  uint64 start_index = 2;
  // If present, the amount that has resulted from aggregating other amounts
  // If this field is present so is `num_aggregated`.
  optional EncryptedAmount aggregated_amount = 3;
  // The number of aggregated amounts (must be at least 2 if present). This
  // field is present if and only if `aggregated_amount` is present.
  optional uint32 num_aggregated = 4;
  // Amounts starting at `start_index` (or at `start_index + 1` if there is
  // an aggregated amount present). They are assumed to be numbered
  // sequentially. The length of this list is bounded by the maximum number
  // of incoming amounts on the accounts, which is currently 32. After
  // that aggregation kicks in.
  repeated EncryptedAmount incoming_amounts = 5;
}

// Entity to which the account delegates a portion of its stake.
message DelegationTarget {
  oneof target {
    // Delegate passively, i.e., to no specific baker.
    Empty passive = 1;
    // Delegate to a specific baker.
    BakerId baker = 2;
  }
}

// Baker's public key used to check whether they won the lottery or not.
message BakerElectionVerifyKey {
  bytes value = 1;
}

// Baker's public key used to check that they are indeed the ones who
// produced the block.
message BakerSignatureVerifyKey {
  bytes value = 1;
}
 
// Baker's public key used to check signatures on finalization records.
// This is only used if the baker has sufficient stake to participate in
// finalization.
message BakerAggregationVerifyKey {
  bytes value = 1;
}

/// Information about a baker.
message BakerInfo {
  // Identity of the baker. This is actually the account index of
  // the account controlling the baker.
  BakerId baker_id = 1;
  // Baker's public key used to check whether they won the lottery or not.
  BakerElectionVerifyKey election_key = 2;
  // Baker's public key used to check that they are indeed the ones who
  // produced the block.
  BakerSignatureVerifyKey signature_key = 3;
  // Baker's public key used to check signatures on finalization records.
  // This is only used if the baker has sufficient stake to participate in
  // finalization.
  BakerAggregationVerifyKey aggregation_key = 4;
}

message StakePendingChange {
  message Reduce {
    Amount new_stake = 1;
    // Timestamp in milliseconds when the change takes effect.
    uint64 effective_time = 2;
  }
  
  oneof change {
    Reduce reduce = 1;
    // Remove the stake. The value is a timestamp of the effective time in
    // milliseconds.
    uint64 remove = 2;
  }
}

// Information about how open the pool is to new delegators.
enum OpenStatus {
  OPEN_STATUS_OPENFORALL = 0;
  OPEN_STATUS_CLOSEDFORNEW = 1;
  OPEN_STATUS_CLOSEDFORALL = 2;
}

// A fraction of an amount with a precision of `1/100_000`.
message AmountFraction {
  uint32 parts_per_hundred_thousand = 1;
}

// Distribution of the rewards for the particular pool.
message CommissionRates {
  // Fraction of finalization rewards charged by the pool owner.
  AmountFraction finalization = 1;
  // Fraction of baking rewards charged by the pool owner.
  AmountFraction baking = 2;
  // Fraction of transaction rewards charged by the pool owner.
  AmountFraction transaction = 3;
}

/// Additional information about a baking pool.
/// This information is added with the introduction of delegation.
message BakerPoolInfo {
  // Whether the pool allows delegators.
  OpenStatus open_status = 1;
  // The URL that links to the metadata about the pool.
  string url = 2;
  // The commission rates charged by the pool owner.
  CommissionRates commission_rates = 3;
}

// Information about the account stake, if the account is either a baker or a
// delegator.
message AccountStakingInfo {
  message Baker {
    Amount staked_amount = 1;
    bool restake_earnings = 2;
    BakerInfo baker_info = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
    // Present if the account is currently a baker, i.e., it is in the baking
    // committee of the current epoch.
    optional BakerPoolInfo pool_info = 5;
  }

  message Delegate {
    // The amount that the account delegates.
    Amount staked_amount = 1;
    // Whether the earnings are automatically added to the staked amount.
    bool restake_earnings = 2;
    // The entity to which the account delegates.
    DelegationTarget target = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
  }

  oneof staking_info {
    // The account is a baker.
    Baker baker = 1;
    // The account is a delegator.
    Delegate delegate = 2;
  }
}

// A sequence number that determines the ordering of transactions from the
// account. The minimum sequence number is 1.
message Nonce {
  // The nonce
  uint64 value = 1;
}

// An amount of microCCD.
message Amount {
  uint64 value = 1;
}

// A credential index of an account.
message CredentialIndex {
  uint32 value = 1;
}

// The number of signatures required to sign.
message SignatureThreshold {
  uint32 value = 1;
}

// The number of credentials required to sign an account transaction.
message AccountThreshold {
  uint32 value = 1;
}

// An account encryption key. Always 96 bytes.
message EncryptionKey {
  bytes value = 1;
}

// An address of an account. Always 32 bytes.
message AccountAddress {
  bytes value = 1;
}

// An addrass is either a contract or account address.
message Address {
  oneof type {
    AccountAddress account = 1;
    ContractAddress contract = 2;
  }
}

// A public key used to verify transaction signatures from an account.
message AccountVerifyKey {
  oneof key {
    bytes ed25519_key = 1;
  }
}

// Public keys of a single credential.
message CredentialPublicKeys {
  map<uint32, AccountVerifyKey> keys = 1;
  SignatureThreshold threshold = 2;
}

// A registration ID of a credential, derived from the secred PRF key and a
// nonce. This is always 48 bytes long.
message CredentialRegistrationId {
  bytes value = 1;
}

// An index of the identity provider that identifies them uniquely in the
// context of a specific chain.
message IdentityProviderIdentity {
  uint32 value = 1;
}

// Representation of the pair of a year and month.
message YearMonth {
  uint32 year = 1;
  uint32 month = 2;
}

// Policy on a credential.
message Policy {
  // The year and month when the identity object from which the credential is
  // derived was created.
  YearMonth created_at = 1;
  // The last year and month when the credential is still valid. After this
  // expires an account can no longer be created from the credential.
  YearMonth valid_to = 2;
  // Mapping from attribute tags to attribute values. Attribute tags are always
  // representable in a single `u8`, attribute values are never more than 31
  // bytes in length.
  map<uint32, bytes> attributes = 3;
}

// Values contained in an initial credential.
message InitialCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
}

/// Data relating to a single anonymity revoker sent by the account holder to
/// the chain.
message ChainArData {
  // Share of the encryption of IdCredPub.
  bytes enc_id_cred_pub_share = 1;
}

// The number of anonymity revokers needed to revoke anonymity of a credential
// holder.
message ArThreshold {
  uint32 value = 1;
}

// A single commitment in the G1 group of the BLS curve.
message Commitment {
  bytes value = 1;
}

// Commitments that are part of a normal credential.
message CredentialCommitments {
  // Commitment to the PRF key.
  Commitment prf = 1;
  // Commitment to the counter used to generate the credential registration id.
  Commitment cred_counter = 2;
  // Commitment to the `max_accounts` value, which determines the maximum number
  // of credentials that may be created from the identity object.
  Commitment max_accounts = 3;
  // Commitments to the attributes which have not been revealed in the policy.
  map<uint32, Commitment> attributes = 4;
  // List of commitments to the coefficients of the sharing polynomial. This
  // polynomial is used in a shared encryption of `id_cred_pub` among the
  // anonymity revokers.
  repeated Commitment id_cred_sec_sharing_coeff = 5;
}

// Values contained in a normal (non-initial) credential.
message NormalCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
  // The number of anonymity revokers that must work together to revoke the
  // anonymity of the credential holder.
  ArThreshold ar_threshold = 5;
  // Mapping from anonymity revoker identities to revocation data for the given anonymity revoker.
  map<uint32, ChainArData> ar_data = 6;
  // Commitments to attributes which have not been revealed.
  CredentialCommitments commitments = 7;
}

message AccountCredential {
  oneof credential_values {
    InitialCredentialValues initial = 1;
    NormalCredentialValues normal = 2;
  }
}

message CredentialType {
  oneof type {
    Empty initial = 1;
    Empty normal = 2;
  }
}

message AccountInfo {
  // Next sequence number to be used for transactions signed from this account.
  Nonce nonce = 1;
  // Current (unencrypted) balance of the account.
  Amount amount = 2;
  // Release schedule for any locked up amount. This could be an empty
  // release schedule.
  ReleaseSchedule schedule = 3;
  // Map of all currently active credentials on the account.
  // This includes public keys that can sign for the given credentials, as
  // well as any revealed attributes. This map always contains a credential
  // with index 0.
  map<uint32, AccountCredential> creds = 4;
  // Lower bound on how many credentials must sign any given transaction from
  // this account.
  AccountThreshold threshold = 5;
  // The encrypted balance of the account.
  EncryptedBalance encrypted_balance = 6;
  // The public key for sending encrypted balances to the account.
  EncryptionKey encryption_key = 7;
  // Internal index of the account. Accounts on the chain get sequential
  // indices. These should generally not be used outside of the chain,
  // the account address is meant to be used to refer to accounts,
  // however the account index serves the role of the baker id, if the
  // account is a baker. Hence it is exposed here as well.
  AccountIndex index = 8;
  // Present if the account is a baker or delegator. In that case
  // it is the information about the baker or delegator.
  optional AccountStakingInfo stake = 9;
  // Canonical address of the account. This is derived from the first credential
  // that created the account.
  AccountAddress address = 10;
}

message BlockHashInput {
  oneof block_hash_input {
    Empty best = 1;
    Empty last_final = 2;
    BlockHash given = 3;
  }
}

message AccountIdentifierInput {
  oneof account_identifier_input {
    AccountAddress address = 1;
    CredentialRegistrationId cred_id = 2;
    AccountIndex account_index = 3;
  }
}

message AccountInfoRequest {
  BlockHashInput block_hash = 1;
  AccountIdentifierInput account_identifier = 2;
}

// Information about a finalized block that is part of the streaming response.
message FinalizedBlockInfo {
  // Hash of the block.
  BlockHash hash = 1;
  // Absolute height of the block, height 0 is the genesis block.
  AbsoluteBlockHeight height = 2;
}

// Request the ancestors for the given block.
message AncestorsRequest {
  // The block to get ancestors of.
  BlockHashInput block_hash = 1;
  // The maximum number of ancestors returned.
  uint64 amount = 2;
}

// Request for getting the source of a smart contract module.
message ModuleSourceRequest {
  // The block to be used for the query.
  BlockHashInput block_hash = 1;

  // The reference (hash) of the module.
  ModuleRef module_ref = 2;
}

// Address of a smart contract instance.
message ContractAddress {
  // The index of the smart contract.
  uint64 index = 1;
  // The subindex of the smart contract instance.
  // Currently not used, so it is always 0.
  uint64 subindex = 2;
}

message InstanceInfoRequest {
  BlockHashInput block_hash = 1;
  ContractAddress address = 2;
}

// Information about a smart contract instance.
message InstanceInfo {

  message V0 {
    ContractState model = 1;
    AccountAddress owner = 2;
    Amount amount = 3;
    repeated ReceiveName methods = 4;
    InitName name = 5;
    ModuleRef source_module = 6;
  }

  message V1 {
    AccountAddress owner = 2;
    Amount amount = 3;
    repeated ReceiveName methods = 4;
    InitName name = 5;
    ModuleRef source_module = 6;
  }

  oneof version {
    V0 v0 = 1;
    V1 v1 = 2;
  }
}

message ReceiveName {
  string value = 1;
}

message InitName {
  string value = 1;
}

message ContractState {
  bytes value = 1;
}

message TransactionStatus {

  message Committed {
    repeated TransactionSummaryInBlock outcomes = 1;
  }

  message Finalized {
    TransactionSummaryInBlock outcomes = 1; // TODO: Should this also be repeated for when finalization committee is corrupt?
  }

  oneof status {
    Empty received = 1;
    Committed committed = 2;
    Finalized finalized = 3;
  }
}

message TransactionSummaryInBlock {
  BlockHash block_hash = 1;
  optional TransactionSummary outcome = 2; // TODO: This is optional in haskell, why?
}

message Energy {
  uint64 value = 1;
}

message TransactionSummary {
  message AccountTransaction {
    optional TransactionType value = 1; // TODO: Why is this optional in HS?
  }
  message CredentialDeploymentTransaction {
    CredentialType value = 1;
  }
  message UpdateTransaction {
    UpdateType value = 1;
  }
  message TransactionIndex {
    uint64 value = 1;
  }
  message Success {
    message Event {
      message Transferred {
        Address sender = 1;
        Amount amount = 2;
        Address receiver = 3;
      }
      // TODO: implement remaning variants
      oneof type {
        Transferred transferred = 1;
      }
    }
    repeated Event events = 1;
  }
  message Reject {
    message RejectReason {
      Empty value = 1; // TODO: implement
    }
    RejectReason reject_reason = 1;
  }

  optional AccountAddress sender = 1;
  TransactionHash hash = 2;
  Amount cost = 3;
  Energy energy_cost = 4;
  oneof type {
    AccountTransaction account = 5;
    CredentialDeploymentTransaction credential_deployment = 6;
    UpdateTransaction update = 7;
  }
  oneof result {
    Success success = 8;
    Reject reject = 9;
  }
  TransactionIndex index = 10;
}



// TODO: Consider if microgtu/euro should be the default value, as it will be used much more frequently.
// First variant of an enum will be encoded with no bytes.
enum UpdateType {
    UPDATE_PROTOCOL = 0;
    UPDATE_ELECTION_DIFFICULTY = 1;
    UPDATE_EURO_PER_ENERGY = 2;
    UPDATE_MICRO_GTU_PER_EURO = 3;
    UPDATE_FOUNDATION_ACCOUNT = 4;
    UPDATE_MINT_DISTRIBUTION = 5;
    UPDATE_TRANSACTION_FEE_DISTRIBUTION = 6;
    UPDATE_GAS_REWARDS = 7;
    UPDATE_POOL_PARAMETERS = 8;
    ADD_ANONYMITY_REVOKER = 9;
    ADD_IDENTITY_PROVIDER = 10;
    UPDATE_ROOT_KEYS = 11;
    UPDATE_LEVEL1_KEYS = 12;
    UPDATE_LEVEL2_KEYS = 13;
    UPDATE_COOLDOWN_PARAMETERS = 14;
    UPDATE_TIME_PARAMETERS = 15;
}

enum TransactionType {
  DEPLOY_MODULE = 0;
  INIT_CONTRACT = 1;
  UPDATE = 2;
  TRANSFER = 3;
  // TODO: implement rest
}

message NextAccountNonce {
  Nonce nonce = 1;
  bool all_final = 2;
}
