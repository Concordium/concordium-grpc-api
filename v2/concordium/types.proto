syntax = "proto3";

package concordium.v2;

// A message that contains no information.
message Empty {
}

// Hash of a block. This is always 32 bytes long.
message BlockHash {
  bytes value = 1;
}

// A SHA256 hash. This is always 32 bytes long.
message Sha256Hash {
  bytes value = 1;
}

// Hash of a transaction. This is always 32 bytes long.
message TransactionHash {
  bytes value = 1;
}

// The absolute height of a block.
message AbsoluteBlockHeight {
  uint64 value = 1;
}

// The height of a block relative to the last genesis.
message BlockHeight {
  uint64 value = 1;
}

// The ID of a baker, which is the index of its account.
message BakerId {
  uint64 value = 1;
}

// Index of the account in the account table. These are assigned sequentially
// in the order of creation of accounts. The first account has index 0.
message AccountIndex {
  uint64 value = 1;
}

// Reference (hash) of a smart contract module. This is always 32 bytes long.
message ModuleRef {
  bytes value = 1;
}

//! Source bytes of a smart contract module.
// ok test
message ModuleSource {
  bytes value = 1;
}

// An individual release of a locked balance.
message Release {
  // Effective time of the release in milliseconds since unix epoch.
  uint64 timestamp = 1;
  // Amount to be released.
  Amount amount = 2;
  // List of transaction hashes that contribute a balance to this release.
  repeated TransactionHash transactions = 3;
}

// A new individual release. Part of a single transfer with schedule transaction.
message NewRelease {
  // Effective time of the release in milliseconds since unix epoch.
  uint64 timestamp = 1;
  // Amount to be released.
  Amount amount = 2;
}

// State of the account's release schedule. This is the balance of the account
// that is owned by the account, but cannot be used until the release point.
message ReleaseSchedule {
  Amount total = 1;
  repeated Release schedules = 2;
}

// An encrypted amount, in two chunks in "little endian limbs". That is, the
// first chunk represents the low 32 bits of an amount, and the second chunk
// represents the high 32 bits. The chunks are serialized in order and
// represented as a byte array.
// Always 192 bytes.
message EncryptedAmount {
  bytes value = 1;
}

message EncryptedBalance {
  // Encrypted amount that is a result of this accounts' actions.
  // In particular this list includes the aggregate of
  //
  // - remaining amounts that result when transfering to public balance
  // - remaining amounts when transfering to another account
  // - encrypted amounts that are transferred from public balance
  //
  // When a transfer is made all of these must always be used.
  EncryptedAmount self_amount = 1;
  // Starting index for incoming encrypted amounts. If an aggregated amount
  // is present then this index is associated with such an amount and the
  // list of incoming encrypted amounts starts at the index `start_index
  // + 1`.
  uint64 start_index = 2;
  // If present, the amount that has resulted from aggregating other amounts
  // If this field is present so is `num_aggregated`.
  optional EncryptedAmount aggregated_amount = 3;
  // The number of aggregated amounts (must be at least 2 if present). This
  // field is present if and only if `aggregated_amount` is present.
  optional uint32 num_aggregated = 4;
  // Amounts starting at `start_index` (or at `start_index + 1` if there is
  // an aggregated amount present). They are assumed to be numbered
  // sequentially. The length of this list is bounded by the maximum number
  // of incoming amounts on the accounts, which is currently 32. After
  // that aggregation kicks in.
  repeated EncryptedAmount incoming_amounts = 5;
}

// Entity to which the account delegates a portion of its stake.
message DelegationTarget {
  oneof target {
    // Delegate passively, i.e., to no specific baker.
    Empty passive = 1;
    // Delegate to a specific baker.
    BakerId baker = 2;
  }
}

// Baker's public key used to check whether they won the lottery or not.
message BakerElectionVerifyKey {
  bytes value = 1;
}

// Baker's public key used to check that they are indeed the ones who
// produced the block.
message BakerSignatureVerifyKey {
  bytes value = 1;
}
 
// Baker's public key used to check signatures on finalization records.
// This is only used if the baker has sufficient stake to participate in
// finalization.
message BakerAggregationVerifyKey {
  bytes value = 1;
}

// Information about a baker.
message BakerInfo {
  // Identity of the baker. This is actually the account index of
  // the account controlling the baker.
  BakerId baker_id = 1;
  // Baker's public key used to check whether they won the lottery or not.
  BakerElectionVerifyKey election_key = 2;
  // Baker's public key used to check that they are indeed the ones who
  // produced the block.
  BakerSignatureVerifyKey signature_key = 3;
  // Baker's public key used to check signatures on finalization records.
  // This is only used if the baker has sufficient stake to participate in
  // finalization.
  BakerAggregationVerifyKey aggregation_key = 4;
}

message StakePendingChange {
  message Reduce {
    Amount new_stake = 1;
    // Timestamp in milliseconds when the change takes effect.
    uint64 effective_time = 2;
  }
  
  oneof change {
    Reduce reduce = 1;
    // Remove the stake. The value is a timestamp of the effective time in
    // milliseconds.
    uint64 remove = 2;
  }
}

// Information about how open the pool is to new delegators.
enum OpenStatus {
  OPEN_STATUS_OPENFORALL = 0;
  OPEN_STATUS_CLOSEDFORNEW = 1;
  OPEN_STATUS_CLOSEDFORALL = 2;
}

// A fraction of an amount with a precision of `1/100_000`.
message AmountFraction {
  uint32 parts_per_hundred_thousand = 1;
}

// Distribution of the rewards for the particular pool.
message CommissionRates {
  // Fraction of finalization rewards charged by the pool owner.
  AmountFraction finalization = 1;
  // Fraction of baking rewards charged by the pool owner.
  AmountFraction baking = 2;
  // Fraction of transaction rewards charged by the pool owner.
  AmountFraction transaction = 3;
}

// Additional information about a baking pool.
// This information is added with the introduction of delegation.
message BakerPoolInfo {
  // Whether the pool allows delegators.
  OpenStatus open_status = 1;
  // The URL that links to the metadata about the pool.
  string url = 2;
  // The commission rates charged by the pool owner.
  CommissionRates commission_rates = 3;
}

// Information about the account stake, if the account is either a baker or a
// delegator.
message AccountStakingInfo {
  message Baker {
    Amount staked_amount = 1;
    bool restake_earnings = 2;
    BakerInfo baker_info = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
    // Present if the account is currently a baker, i.e., it is in the baking
    // committee of the current epoch.
    optional BakerPoolInfo pool_info = 5;
  }

  message Delegate {
    // The amount that the account delegates.
    Amount staked_amount = 1;
    // Whether the earnings are automatically added to the staked amount.
    bool restake_earnings = 2;
    // The entity to which the account delegates.
    DelegationTarget target = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
  }

  oneof staking_info {
    // The account is a baker.
    Baker baker = 1;
    // The account is a delegator.
    Delegate delegate = 2;
  }
}

// A sequence number that determines the ordering of transactions from the
// account. The minimum sequence number is 1.
message Nonce {
  // The nonce
  uint64 value = 1;
}

// An amount of microCCD.
message Amount {
  uint64 value = 1;
}

// A credential index of an account.
message CredentialIndex {
  uint32 value = 1;
}

// The number of signatures required to sign.
message SignatureThreshold {
  uint32 value = 1;
}

// The number of credentials required to sign an account transaction.
message AccountThreshold {
  uint32 value = 1;
}

// An account encryption key. Always 96 bytes.
message EncryptionKey {
  bytes value = 1;
}

// An address of an account. Always 32 bytes.
message AccountAddress {
  bytes value = 1;
}

// An addrass is either a contract or account address.
message Address {
  oneof type {
    AccountAddress account = 1;
    ContractAddress contract = 2;
  }
}

// A public key used to verify transaction signatures from an account.
message AccountVerifyKey {
  oneof key {
    bytes ed25519_key = 1;
  }
}

// Public keys of a single credential.
message CredentialPublicKeys {
  map<uint32, AccountVerifyKey> keys = 1;
  SignatureThreshold threshold = 2;
}

// A registration ID of a credential, derived from the secred PRF key and a
// nonce. This is always 48 bytes long.
message CredentialRegistrationId {
  bytes value = 1;
}

// An index of the identity provider that identifies them uniquely in the
// context of a specific chain.
message IdentityProviderIdentity {
  uint32 value = 1;
}

// Representation of the pair of a year and month.
message YearMonth {
  uint32 year = 1;
  uint32 month = 2;
}

// Policy on a credential.
message Policy {
  // The year and month when the identity object from which the credential is
  // derived was created.
  YearMonth created_at = 1;
  // The last year and month when the credential is still valid. After this
  // expires an account can no longer be created from the credential.
  YearMonth valid_to = 2;
  // Mapping from attribute tags to attribute values. Attribute tags are always
  // representable in a single `u8`, attribute values are never more than 31
  // bytes in length.
  map<uint32, bytes> attributes = 3;
}

// Values contained in an initial credential.
message InitialCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
}

// Data relating to a single anonymity revoker sent by the account holder to
// the chain.
message ChainArData {
  // Share of the encryption of IdCredPub.
  bytes enc_id_cred_pub_share = 1;
}

// The number of anonymity revokers needed to revoke anonymity of a credential
// holder.
message ArThreshold {
  uint32 value = 1;
}

// A single commitment in the G1 group of the BLS curve.
message Commitment {
  bytes value = 1;
}

// Commitments that are part of a normal credential.
message CredentialCommitments {
  // Commitment to the PRF key.
  Commitment prf = 1;
  // Commitment to the counter used to generate the credential registration id.
  Commitment cred_counter = 2;
  // Commitment to the `max_accounts` value, which determines the maximum number
  // of credentials that may be created from the identity object.
  Commitment max_accounts = 3;
  // Commitments to the attributes which have not been revealed in the policy.
  map<uint32, Commitment> attributes = 4;
  // List of commitments to the coefficients of the sharing polynomial. This
  // polynomial is used in a shared encryption of `id_cred_pub` among the
  // anonymity revokers.
  repeated Commitment id_cred_sec_sharing_coeff = 5;
}

// Values contained in a normal (non-initial) credential.
message NormalCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
  // The number of anonymity revokers that must work together to revoke the
  // anonymity of the credential holder.
  ArThreshold ar_threshold = 5;
  // Mapping from anonymity revoker identities to revocation data for the given anonymity revoker.
  map<uint32, ChainArData> ar_data = 6;
  // Commitments to attributes which have not been revealed.
  CredentialCommitments commitments = 7;
}

message AccountCredential {
  oneof credential_values {
    InitialCredentialValues initial = 1;
    NormalCredentialValues normal = 2;
  }
}

message CredentialType {
  oneof type {
    Empty initial = 1;
    Empty normal = 2;
  }
}

message AccountInfo {
  // Next sequence number to be used for transactions signed from this account.
  Nonce nonce = 1;
  // Current (unencrypted) balance of the account.
  Amount amount = 2;
  // Release schedule for any locked up amount. This could be an empty
  // release schedule.
  ReleaseSchedule schedule = 3;
  // Map of all currently active credentials on the account.
  // This includes public keys that can sign for the given credentials, as
  // well as any revealed attributes. This map always contains a credential
  // with index 0.
  map<uint32, AccountCredential> creds = 4;
  // Lower bound on how many credentials must sign any given transaction from
  // this account.
  AccountThreshold threshold = 5;
  // The encrypted balance of the account.
  EncryptedBalance encrypted_balance = 6;
  // The public key for sending encrypted balances to the account.
  EncryptionKey encryption_key = 7;
  // Internal index of the account. Accounts on the chain get sequential
  // indices. These should generally not be used outside of the chain,
  // the account address is meant to be used to refer to accounts,
  // however the account index serves the role of the baker id, if the
  // account is a baker. Hence it is exposed here as well.
  AccountIndex index = 8;
  // Present if the account is a baker or delegator. In that case
  // it is the information about the baker or delegator.
  optional AccountStakingInfo stake = 9;
  // Canonical address of the account. This is derived from the first credential
  // that created the account.
  AccountAddress address = 10;
}

message BlockHashInput {
  oneof block_hash_input {
    Empty best = 1;
    Empty last_final = 2;
    BlockHash given = 3;
  }
}

message AccountInfoRequest {
  BlockHashInput block_hash = 1;
  oneof account_identifier {
    AccountAddress address = 2;
    CredentialRegistrationId cred_id = 3;
    AccountIndex account_index = 4;
  }
}

// Information about a finalized block that is part of the streaming response.
message FinalizedBlockInfo {
  // Hash of the block.
  BlockHash hash = 1;
  // Absolute height of the block, height 0 is the genesis block.
  AbsoluteBlockHeight height = 2;
}

// Request the ancestors for the given block.
message AncestorsRequest {
  // The block to get ancestors of.
  BlockHashInput block_hash = 1;
  // The maximum number of ancestors returned.
  uint64 amount = 2;
}

// Request for getting the source of a smart contract module.
message ModuleSourceRequest {
  // The block to be used for the query.
  BlockHashInput block_hash = 1;

  // The reference (hash) of the module.
  ModuleRef module_ref = 2;
}

// Address of a smart contract instance.
message ContractAddress {
  // The index of the smart contract.
  uint64 index = 1;
  // The subindex of the smart contract instance.
  // Currently not used, so it is always 0.
  uint64 subindex = 2;
}

message InstanceInfoRequest {
  BlockHashInput block_hash = 1;
  ContractAddress address = 2;
}

// Information about a smart contract instance.
message InstanceInfo {

  message V0 {
    ContractState model = 1;
    AccountAddress owner = 2;
    Amount amount = 3;
    repeated ReceiveName methods = 4;
    InitName name = 5;
    ModuleRef source_module = 6;
  }

  message V1 {
    AccountAddress owner = 2;
    Amount amount = 3;
    repeated ReceiveName methods = 4;
    InitName name = 5;
    ModuleRef source_module = 6;
  }

  oneof version {
    V0 v0 = 1;
    V1 v1 = 2;
  }
}

message ReceiveName {
  string value = 1;
}

message InitName {
  string value = 1;
}

// Parameter to a smart contract invocation.
message Parameter {
  bytes value = 1;
}

message ContractState {
  bytes value = 1;
}

message TransactionStatus {

  message Committed {
    repeated TransactionSummaryInBlock outcomes = 1;
  }

  message Finalized {
    TransactionSummaryInBlock outcome = 1; // TODO: internalservererror grpc error if there are multiple
  }

  oneof status {
    Empty received = 1;
    Committed committed = 2;
    Finalized finalized = 3;
  }
}

message TransactionSummaryInBlock {
  BlockHash block_hash = 1;
  BlockItemSummary outcome = 2;
}

message Energy {
  uint64 value = 1;
}

message RejectReason {

  message ModuleHashAlreadyExists {
    ModuleRef contents = 1;
  }

  message InvalidAccountReference {
    AccountAddress contents = 1;
  }

  message InvalidInitMethod {
    ModuleRef module_ref = 1;
    InitName init_name = 2;
  }

  message InvalidReceiveMethod {
    ModuleRef module_ref = 1;
    ReceiveName receive_name = 2;
  }

  message InvalidModuleReference {
    ModuleRef contents = 1;
  }

  message InvalidContractAddress {
    ContractAddress contents = 1;
  }

  message AmountTooLarge {
    Address address = 1;
    Amount amount = 2;
  }

  message RejectedInit {
    int32 reject_reason = 1;
  }

  message RejectedReceive {
    int32 reject_reason = 1;
    ContractAddress contract_address = 2;
    ReceiveName receive_name = 3;
    Parameter parameter = 4;
  }

  message AlreadyABaker {
    BakerId contents = 1;
  }

  message NotABaker {
    AccountAddress contents = 1;
  }

  message DuplicateAggregationKey {
    BakerAggregationVerifyKey contents = 1;
  }

  message EncryptedAmountSelfTransfer {
    AccountAddress contents = 1;
  }

  message ScheduledSelfTransfer {
    AccountAddress contents = 1;
  }

  message DuplicateCredIds {
    repeated CredentialRegistrationId contents = 1;
  }

  message NonExistentCredIds {
    repeated CredentialRegistrationId contents = 1;
  }

  message NotADelegator {
    AccountAddress contents = 1;
  }

  message DelegationTargetNotABaker {
    BakerId contents = 1;
  }

  oneof reason {
    // Raised while validating a Wasm module that is not well formed.
    Empty module_not_wf = 1;
    // The smart contract module hash already exists.
    ModuleHashAlreadyExists module_hash_already_exists = 2;
    // Account does not exist.
    InvalidAccountReference invalid_account_reference = 3;
    // Reference to a non-existing contract init method.
    InvalidInitMethod invalid_init_method = 4;
    // Reference to a non-existing contract receive method.
    InvalidReceiveMethod invalid_receive_method = 5;
    // Reference to a non-existing smart contract module.
    InvalidModuleReference invalid_module_reference = 6;
    // Contract instance does not exist.
    InvalidContractAddress invalid_contract_address = 7;
    // Runtime exception occurred when running either the init or receive
    // method.
    Empty runtime_failure = 8;
    // When one wishes to transfer an amount from A to B but there
    // are not enough funds on account/contract A to make this
    // possible. The data are the from address and the amount to transfer.
    AmountTooLarge amount_too_large = 9;
    // Serialization of the body failed.
    Empty serialization_failure = 10;
    // We ran of out energy to process this transaction.
    Empty out_of_energy = 11;
    // Rejected due to contract logic in init function of a contract.
    RejectedInit rejected_init = 12;
    // Rejected due to contract logic in receive function of a contract.
    RejectedReceive rejected_receive = 13;
    // Proof that the baker owns relevant private keys is not valid.
    Empty invalid_proof = 14;
    // Tried to add baker for an account that already has a baker
    AlreadyABaker already_a_baker = 15;
    // Tried to remove a baker for an account that has no baker
    NotABaker not_a_baker = 16;
    // The amount on the account was insufficient to cover the proposed stake
    Empty insufficient_balance_for_baker_stake = 17;
    // The amount provided is under the threshold required for becoming a baker
    Empty stake_under_minimum_threshold_for_baking = 18;
    // The change could not be made because the baker is in cooldown for
    // another change
    Empty baker_in_cooldown = 19;
    // A baker with the given aggregation key already exists
    DuplicateAggregationKey duplicate_aggregation_key = 20;
    // Encountered credential ID that does not exist
    Empty non_existent_credential_id = 21;
    // Attempted to add an account key to a key index already in use
    Empty key_index_already_in_use = 22;
    // When the account threshold is updated, it must not exceed the amount of
    // existing keys
    Empty invalid_account_threshold = 23;
    // When the credential key threshold is updated, it must not exceed the
    // amount of existing keys
    Empty invalid_credential_key_sign_threshold = 24;
    // Proof for an encrypted amount transfer did not validate.
    Empty invalid_encrypted_amount_transfer_proof = 25;
    // Proof for a secret to public transfer did not validate.
    Empty invalid_transfer_to_public_proof = 26;
    // Account tried to transfer an encrypted amount to itself, that's not
    // allowed.
    EncryptedAmountSelfTransfer encrypted_amount_self_transfer = 27;
    // The provided index is below the start index or above `startIndex +
    // length incomingAmounts`
    Empty invalid_index_on_encrypted_transfer = 28;
    // The transfer with schedule is going to send 0 tokens
    Empty zero_scheduledAmount = 29;
    // The transfer with schedule has a non strictly increasing schedule
    Empty non_increasing_schedule = 30;
    // The first scheduled release in a transfer with schedule has already
    // expired
    Empty first_scheduled_release_expired = 31;
    // Account tried to transfer with schedule to itself, that's not allowed.
    ScheduledSelfTransfer scheduled_self_transfer = 32;
    // At least one of the credentials was either malformed or its proof was
    // incorrect.
    Empty invalid_credentials = 33;
    // Some of the credential IDs already exist or are duplicated in the
    // transaction.
    DuplicateCredIds duplicate_cred_ids = 34;
    // A credential id that was to be removed is not part of the account.
    NonExistentCredIds non_existent_cred_ids = 35;
    // Attemp to remove the first credential
    Empty remove_first_credential = 36;
    // The credential holder of the keys to be updated did not sign the
    // transaction
    Empty credential_holder_did_not_sign = 37;
    // Account is not allowed to have multiple credentials because it contains
    // a non-zero encrypted transfer.
    Empty not_allowed_multiple_credentials = 38;
    // The account is not allowed to receive encrypted transfers because it has
    // multiple credentials.
    Empty not_allowed_to_receive_encrypted = 39;
    // The account is not allowed to send encrypted transfers (or transfer
    // from/to public to/from encrypted)
    Empty not_allowed_to_handle_encrypted = 40;
    // A configure baker transaction is missing one or more arguments in order
    // to add a baker.
    Empty missing_baker_add_parameters = 41;
    // Finalization reward commission is not in the valid range for a baker
    Empty finalization_reward_commission_not_in_range = 42;
    // Baking reward commission is not in the valid range for a baker
    Empty baking_reward_commission_not_in_range = 43;
    // Transaction fee commission is not in the valid range for a baker
    Empty transaction_fee_commission_not_in_range = 44;
    // Tried to add baker for an account that already has a delegator.
    Empty already_a_delegator = 45;
    // The amount on the account was insufficient to cover the proposed stake.
    Empty insufficient_balance_for_delegation_stake = 46;
    // A configure delegation transaction is missing one or more arguments in
    // order to add a delegator.
    Empty missing_delegation_add_parameters = 47;
    // Delegation stake when adding a delegator was 0.
    Empty insufficient_delegation_stake = 48;
    // Account is not a delegation account.
    Empty delegator_in_cooldown = 49;
    // Account is not a delegation account.
    NotADelegator not_a_delegator = 50;
    // Delegation target is not a baker
    DelegationTargetNotABaker delegation_target_not_a_baker = 51;
    // The amount would result in pool capital higher than the maximum
    // threshold.
    Empty stake_over_maximum_threshold_for_pool = 52;
    // The amount would result in pool with a too high fraction of delegated
    // capital.
    Empty pool_would_become_over_delegated = 53;
    // The pool is not open to delegators.
    Empty pool_closed = 54;
  }
}

// Version of smart contract.
enum ContractVersion {
  V0 = 0;
  V1 = 1;
}


/// Data generated as part of initializing a single contract instance.
message ContractInitializedEvent {
  // Contract version.
  ContractVersion contract_version = 1;
  // Module with the source code of the contract.
  ModuleRef origin_ref = 2;
  // The newly assigned address of the contract.
  ContractAddress address = 3;
  // The amount the instance was initialized with.
  Amount amount = 4;
  // The name of the contract.
  InitName init_name = 5;
  // Any contract events that might have been genereated by the contract initialization.
  repeated ContractEvent events = 6;
}

// Events that come from inside a smart contract.
message ContractEvent {
  bytes value = 1;
}

/// Data generated as part of updating a single contract instance.
/// In general a single Update transaction will
/// generate one or more of these events, together with possibly some transfers.
message InstanceUpdatedEvent {
  // Contract version.
  ContractVersion contract_version = 1;
  // Address of the affected instance.
  ContractAddress address = 2;
  // The origin of the message to the smart contract. This can be
  // either an account or a smart contract.
  Address instigator = 3;
  // The amount the method was invoked with.
  Amount amount = 4;
  // The parameter passed to the method.
  Parameter parameter = 5;
  // The name of the method that was executed.
  ReceiveName receive_name = 6;
  // Any contract events that might have been generated by the contract execution.
  repeated ContractEvent events = 7;
}

message ContractTraceElement {
  // A contract instance was updated.
  message Updated {
    InstanceUpdatedEvent contents = 1;
  }
  // A contract transferred an amount to an account.
  message Transferred {
    // Sender contract.
    ContractAddress from = 1;
    // Amount transferred.
    Amount amount = 2;
    // Receiver account.
    AccountAddress to_ = 3;
  }
  // A contract was interrupted.
  // This occurs when a contract invokes another contract or makes a transfer to an account.
  message Interrupted {
    // The contract interrupted.
    ContractAddress address = 1;
    // The events generated up until the interruption.
    repeated ContractEvent events = 2;
  }
  // A previously interrupted contract was resumed.
  message Resumed {
    // The contract resumed.
    ContractAddress address = 1;
    // Whether the action that caused the interruption (invoke contract or make transfer) was successful or not.
    bool success = 2;
  }

  oneof element {
    Updated updated = 1;
    Transferred transferred = 2;
    Interrupted interrupted = 3;
    Resumed resumed = 4;
  }
}

// Result of a successful change of baker keys.
message BakerKeysEvent {
    // ID of the baker whose keys were changed.
    BakerId baker_id = 1;
    // Account address of the baker.
    AccountAddress account = 2;
    // The new public key for verifying block signatures.
    BakerSignatureVerifyKey sign_key = 3;
    // The new public key for verifying whether the baker won the block
    // lottery.
    BakerElectionVerifyKey election_key = 4;
    // The new public key for verifying finalization records.
    BakerAggregationVerifyKey aggregation_key = 5;
}

// A memo which can be included as part of a transfer.
message Memo {
  bytes value = 1;
}

message BakerStakeUpdatedData {
  // Affected baker.
  BakerId baker_id = 1;
  // New stake.
  Amount new_stake = 2;
  // A boolean which indicates whether it increased
  // (`true`) or decreased (`false`).
  bool increased = 3;
}

// Event generated when one or more encrypted amounts are consumed from the account.
message EncryptedAmountRemovedEvent {
  // The affected account.
  AccountAddress account = 1;
  // The new self encrypted amount on the affected account.
  EncryptedAmount new_amount = 2;
  // The input encrypted amount that was removed.
  EncryptedAmount input_amount = 3;
  // The index indicating which amounts were used.
  uint64 up_to_index = 4;
}

// Event generated when an account receives a new encrypted amount.
message NewEncryptedAmountEvent {
    // The account onto which the amount was added.
    AccountAddress receiver = 1;
    // The index the amount was assigned.
    uint64 new_index = 2;
    // The encrypted amount that was added.
    EncryptedAmount encrypted_amount = 3;
}

message EncryptedSelfAmountAddedEvent {
 // The affected account.
 AccountAddress account = 1;
 // The new self encrypted amount of the account.
 EncryptedAmount new_amount = 2;
 // The amount that was transferred from public to encrypted balance.
 Amount amount = 3;
}

// Unix timestamp in milliseconds.
message Timestamp {
  uint64 value = 1;
}

// Data registered on the chain with a register data transaction.
message RegisteredData {
  bytes value = 1;
}

// Events that may result from the ConfigureBaker transaction.
message BakerEvent {
  // A baker was added.
  message BakerAdded {
    // The keys with which the baker registered.
    BakerKeysEvent keys_event = 1;
    // The amount the account staked to become a baker. This amount is
    // locked.
    Amount stake = 2;
    // Whether the baker will automatically add earnings to their stake or
    // not.
    bool restake_earnings = 3;
  }
  // A baker was removed.
  message BakerRemoved {
    // Baker's id.
    BakerId baker_id = 1;
  }
  // Baker stake increased.
  message BakerStakeIncreased {
    // Baker's id.
    BakerId baker_id = 1;
    // The new stake.
    Amount new_stake = 2;
  }
  message BakerStakeDecreased {
    // Baker's id.
    BakerId baker_id = 1;
    // The new stake.
    Amount new_stake = 2;
  }
  message BakerRestakeEarningsUpdated {
    // Baker's id.
    BakerId baker_id = 1;
    // The new value of the flag.
    bool restake_earnings = 2;
  }
  // The baker's keys were updated.
  message BakerKeysUpdated {
    BakerKeysEvent contents = 1;
  }
  // Updated open status for a baker pool.
  message BakerSetOpenStatus {
    // Baker's id.
    BakerId baker_id = 1;
    // The new open status.
    OpenStatus open_status = 2;
  }
  // Updated metadata url for a baker pool.
  message BakerSetMetadataUrl {
    // Baker's id.
    BakerId baker_id = 1;
    // The URL.
    string url = 2;
  }
  // Updated transaction fee commission for a baker pool.
  message BakerSetTransactionFeeCommission {
    // Baker's id.
    BakerId baker_id = 1;
    // The transaction fee commission.
    AmountFraction transaction_fee_commission = 2;
  }
  // Updated baking reward commission for baker pool
  message BakerSetBakingRewardCommission {
    // Baker's id
    BakerId baker_id = 1;
    // The baking reward commission
    AmountFraction baking_reward_commission = 2;
  }
  // Updated finalization reward commission for baker pool
  message BakerSetFinalizationRewardCommission {
    // Baker's id
    BakerId baker_id = 1;
    /// The finalization reward commission
    AmountFraction finalization_reward_commission = 2;
  }
  oneof event {
    BakerAdded baker_added = 1;
    BakerRemoved baker_removed = 2;
    BakerStakeIncreased baker_stake_increased = 3;
    BakerStakeDecreased baker_stake_decreased = 4;
    BakerRestakeEarningsUpdated baker_restake_earnings_updated = 5;
    BakerKeysUpdated baker_keys_updated = 6;
    BakerSetOpenStatus baker_set_open_status = 7;
    BakerSetMetadataUrl baker_set_metadata_url = 8;
    BakerSetTransactionFeeCommission baker_set_transaction_fee_commission = 9;
    BakerSetBakingRewardCommission baker_set_baking_reward_commission = 10;
    BakerSetFinalizationRewardCommission baker_set_finalization_reward_commission = 11;
  }
}

// The identifier for a delegator.
message DelegatorId {
  AccountIndex id = 1;
}

message DelegationEvent {
  message DelegationStakeIncreased {
    /// Delegator's id
    DelegatorId delegator_id = 1;
    /// New stake
    Amount new_stake = 2;
  }
  message DelegationStakeDecreased {
    /// Delegator's id
    DelegatorId delegator_id = 1;
    /// New stake
    Amount new_stake = 2;
  }
  message DelegationSetRestakeEarnings {
    /// Delegator's id
    DelegatorId delegator_id = 1;
    /// Whether earnings will be restaked
    bool restake_earnings = 2;
  }
  message DelegationSetDelegationTarget {
    /// Delegator's id
    DelegatorId delegator_id = 1;
    /// New delegation target
    DelegationTarget delegation_target = 2;
  }

  message DelegationAdded {
    /// Delegator's id
    DelegatorId delegator_id = 1;
  }
  message DelegationRemoved {
    /// Delegator's id
    DelegatorId delegator_id = 1;
  }
  oneof event {
    DelegationStakeIncreased delegation_stake_increased = 1;
    DelegationStakeDecreased delegation_stake_decreased = 2;
    DelegationSetRestakeEarnings delegation_set_restake_earnings = 3;
    DelegationSetDelegationTarget delegation_set_delegation_target = 4;
    DelegationAdded delegation_added = 5;
    DelegationRemoved delegation_removed = 6;
  }
}

message AccountTransactionEffects {
  // No effects other than payment from this transaction.
  // The rejection reason indicates why the transaction failed.
  message None {
    // Transaction type of a failed transaction, if known.
    // In case of serialization failure this will not be set.
    optional TransactionType transaction_type = 1;
    // Reason for rejection of the transaction.
    RejectReason reject_reason = 2;
  }
  // A module was deployed. This corresponds to
  // [`DeployModule`](transactions::Payload::DeployModule) transaction
  // type.
  message ModuleDeployed {
    ModuleRef module_ref = 1;
  }
  // A contract was initialized was deployed. This corresponds to
  // [`InitContract`](transactions::Payload::InitContract) transaction type.
  message ContractInitialized{
    ContractInitializedEvent contents = 1;
  }
  // A contract update transaction was issued and produced the given trace.
  // This is the result of [Update](transactions::Payload::Update)
  // transaction.
  message ContractUpdateIssued {
    repeated ContractTraceElement effects = 1;
  }
  // A simple account to account transfer occurred. This is the result of a
  // successful [`Transfer`](transactions::Payload::Transfer) transaction.
  message AccountTransfer {
    // Amount that was transferred.
    Amount amount = 1;
    // Receiver account.
    AccountAddress to_ = 2;
    // Memo.
    optional Memo memo = 3;
  }
  // An account was deregistered as a baker. This is the result of a
  // successful [`UpdateBakerStake`](transactions::Payload::UpdateBakerStake)
  // transaction.
  message BakerStakeUpdated {
    // If the stake was updated (that is, it changed and did not stay the
    // same) then this is [Some], otherwise [None].
    optional BakerStakeUpdatedData contents = 1;
  }
  // An encrypted amount was transferred. This is the result of a successful
  // [`EncryptedAmountTransfer`](
  //   transactions::Payload::EncryptedAmountTransfer) transaction.
  message EncryptedAmountTransferred {
    EncryptedAmountRemovedEvent removed = 1;
    NewEncryptedAmountEvent added = 2;
    optional Memo memo = 3;
  }
  // An account transferred part of its public balance to its encrypted
  // balance. This is the result of a successful
  // [`TransferToEncrypted`](transactions::Payload::TransferToEncrypted)
  // transaction.
  message TransferredToEncrypted {
    EncryptedSelfAmountAddedEvent contents = 1;
  }
  // An account transferred part of its encrypted balance to its public
  // balance. This is the result of a successful
  // [`TransferToPublic`](transactions::Payload::TransferToPublic)
  // transaction.
  message TransferredToPublic {
    EncryptedAmountRemovedEvent removed = 1;
    Amount amount = 2;
  }
  // A transfer with schedule was performed. This is the result of a
  // successful
  // [`TransferWithSchedule`](transactions::Payload::TransferWithSchedule)
  // transaction.
  message TransferredWithSchedule {
    // Receiver account.
    AccountAddress to_ = 1;
    // The list of releases. Ordered by increasing timestamp.
    repeated NewRelease amount = 2;
    // Optional memo.
    optional Memo memo = 3;
  }
  // Keys of a specific credential were updated. This is the result of a
  // successful
  // [`UpdateCredentialKeys`](transactions::Payload::UpdateCredentialKeys)
  // transaction.
  message CredentialKeysUpdated {
    // ID of the credential whose keys were updated.
    CredentialRegistrationId cred_id = 1;
  }
  // Account's credentials were updated. This is the result of a
  // successful
  // [`UpdateCredentials`](transactions::Payload::UpdateCredentials)
  // transaction.
  message CredentialsUpdated {
    // The credential ids that were added.
    repeated CredentialRegistrationId new_cred_ids = 1;
    // The credentials that were removed.
    repeated CredentialRegistrationId removed_cred_ids = 2;
    // The (possibly) updated account threshold.
    AccountThreshold new_threshold = 3;
  }
  // Some data was registered on the chain. This is the result of a
  // successful [`RegisterData`](transactions::Payload::RegisterData)
  // transaction.
  message DataRegistered {
    RegisteredData contents = 1;
  }
  // A baker was configured. The details of what happened are contained in
  // the list of [baker events](BakerEvent).
  message BakerConfigured {
    repeated BakerEvent contents = 1;
  }
  // An account configured delegation. The details of what happened are
  // contained in the list of [delegation events](DelegationEvent).
  message DelegationConfigured {
    repeated DelegationEvent contents = 1;
  }

  oneof effect {
    None none = 1;
    ModuleDeployed module_deployed = 2;
    ContractInitialized contract_initialized = 3;
    ContractUpdateIssued contract_update_issued = 4;
    AccountTransfer account_transfer = 5;
    BakerEvent.BakerAdded baker_added = 6;
    BakerEvent.BakerRemoved baker_removed = 7;
    BakerStakeUpdated baker_stake_updated = 8;
    BakerEvent.BakerRestakeEarningsUpdated baker_restake_earnings_updated = 9;
    BakerEvent.BakerKeysUpdated baker_keys_updated = 10;
    EncryptedAmountTransferred encrypted_amount_transferred = 11;
    TransferredToEncrypted transferred_to_encrypted = 12;
    TransferredToPublic transferred_to_public = 13;
    TransferredWithSchedule transferred_with_schedule = 14;
    CredentialKeysUpdated credential_keys_updated = 15;
    CredentialsUpdated credentials_updated = 16;
    DataRegistered data_registered = 17;
    BakerConfigured baker_configured = 18;
    DelegationConfigured delegation_configured = 19;
  }
}

message ElectionDifficulty {
  AmountFraction value = 1;
}

// Represents an exchange rate.
message ExchangeRate {
  Ratio value = 1;
}

// Represents a ratio, i.e., 'numerator / denominator'.
message Ratio {
  // The numerator.
  uint64 numerator = 1;
  // The denominator.
  uint64 denominator = 2;
}

message UpdatePublicKey {
  bytes value = 1;
}

message UpdateKeysThreshold {
  // Is ensured to be within between 1 and 2^16.
  uint32 value = 1;
}

// Index of a key in an authorizations update payload.
message UpdateKeyIndex {
  uint32 value = 1;
}

// Represents root or level 1 keys.
message HigherLevelKeys {
  repeated UpdatePublicKey keys = 1;
  UpdateKeysThreshold threshold = 2;
}

message AccessStructure {
  // Unique indexes into the set of keys in AuthorizationV0.
  repeated UpdateKeyIndex access_public_keys = 1;
  // Number of keys requred to authorize an update.
  UpdateKeysThreshold access_threshold = 2;
}

// The set of keys authorized for chain updates, together with access structures
// determining which keys are authorized for which update types.
// This is the payload of an update to authorization.
message AuthorizationsV0 {
  // The set of keys authorized for chain updates.
  repeated UpdatePublicKey keys = 1;
  // New emergency keys.
  AccessStructure emergency = 2;
  // New protocol update keys.
  AccessStructure protocol = 3;
  // Access structure for updating the election difficulty.
  AccessStructure parameter_election_difficulty = 4;
  // Access structure for updating the euro per energy.
  AccessStructure parameter_euro_per_energy = 5;
  // Access structure for updating the micro CCD per euro.
  AccessStructure parameter_micro_CCD_per_euro = 6;
  // Access structure for updating the foundation account.
  AccessStructure parameter_foundation_account = 7;
  // Access structure for updating the mint distribution.
  AccessStructure parameter_mint_distribution = 8;
  // Access structure for updating the transaction fee distribution.
  AccessStructure parameter_transaction_fee_distribution = 9;
  // Access structure for updating the gas rewards.
  AccessStructure parameter_gas_rewards = 10;
  // Access structure for updating the pool parameters. For V0 this is only
  // the baker stake threshold, for V1 there are more.
  AccessStructure pool_parameters = 11;
  // Access structure for adding new anonymity revokers.
  AccessStructure add_anonymity_revoker = 12;
  // Access structure for adding new identity providers.
  AccessStructure add_identity_provider = 13;
}

// The set of keys authorized for chain updates, together with access structures
// determining which keys are authorized for which update types.
// This is the payload of an update to authorization.
message AuthorizationsV1 {
  AuthorizationsV0 v0 = 1;
  // Access structure for updating the cooldown periods related to baking and delegation.
  AccessStructure parameter_cooldown = 2;
  // Access structure for updating the length of the reward period.
  AccessStructure parameter_time = 3;
}

// Description either of an anonymity revoker or identity provider.
// Metadata that should be visible on the chain.
message Description {
  string name = 1;
  string url = 2;
  string description = 3;
}

// Information on a single anonymity revoker help by the identity provider.
// Typically an identity provider will hold more than one.
message ArInfo {
  // Identity of the anonymity revoker on the chain. This defines their
  // evaluateion point for secret sharing, and thus it cannot be 0.
  message ArIdentity {
    uint32 value = 1;
  }
  // Public key of an anonymity revoker.
  message ArPublicKey {
    bytes value = 1;
  }
  // Unique identifier of the anonymity revoker.
  ArIdentity identity = 1;
  // Description of the anonymity revoker.
  Description description = 2;
  // Elgamal encryption key of the anonymity revoker.
  ArPublicKey public_key = 3;
}

// A succinct identifier of an identity provider on the chain.
// In credential deployments, and other interactions with the chain this is
// used to identify which identity provider is meant.
message IpIdentity {
  uint32 value = 1;
}

/// Public information about an identity provider.
message IpInfo {
  // Pointcheval-Sanders public key of the identity provider.
  message IpVerifyKey {
    bytes value = 1;
  }
  // Ed25519 public key of the identity provider.
  message IpCdiVerifyKey {
    bytes value = 1;
  }
  // Unique identifier of the identity provider.
  IpIdentity identity = 1;
  // Description of the identity provider.
  Description description = 2;
  // Pointcheval-Sanders public key of the identity provider.
  IpVerifyKey verify_key = 3;
  // Ed25519 public key of the identity provider.
  IpCdiVerifyKey cdi_verify_key = 4;
}

// A duration in seconds.
message DurationSeconds {
  uint64 value = 1;
}

// Inclusive range of amount fractions.
message InclusiveRangeAmountFraction {
  AmountFraction min = 1;
  AmountFraction max_ = 2;
}

// Ranges of allowed commission values that pools may choose from.
message CommissionRanges {
  // The range of allowed finalization commissions.
  InclusiveRangeAmountFraction finalization = 1;
  // The range of allowed baker commissions.
  InclusiveRangeAmountFraction baking = 2;
  // The range of allowed transaction commissions.
  InclusiveRangeAmountFraction transaction = 3;
}

// A bound on the relative share of the total staked capital that a baker can
// have as its stake. This is required to be greater than 0.
message CapitalBound {
  AmountFraction value = 1;
}

// A leverage factor.
message LeverageFactor {
  Ratio value = 1;
}

// A chain epoch.
message Epoch {
  uint64 value = 1;
}

// Length of a reward period in epochs.
// Must always be a strictly positive number.
message RewardPeriodLength {
  Epoch value = 1;
}

// A minting rate of CCD.
message MintRate {
  uint32 mantissa = 1;
  // This will never exceed 255 and can thus be stored in a single byte.
  uint32 exponent = 2;
}

message UpdatePayload {
  message ProtocolUpdatePayload {
    // A brief message about the update.
    string message_ = 1;
    // A URL of a document describing the update.
    string specification_url = 2;
    // SHA256 hash of the specification document.
    Sha256Hash specificationHash = 3;
    // Auxiliary data whose interpretation is defined by the new specification.
    bytes specification_auxiliary_data = 4;
  }
  message MintDistributionUpdatePayload {
    MintRate mint_distribution = 1;
    AmountFraction baking_reward = 2;
    AmountFraction finalization_reward = 3;
  }
  message TransactionFeeDistributionUpdatePayload {
    // The fraction allocated to the baker.
    AmountFraction baker = 1;
    // The fraction allocated to the GAS account.
    AmountFraction gas_account = 2;
  }
  message GasRewardsUpdatePayload {
    // The fraction paid to the baker.
    AmountFraction baker = 1;
    // Fraction paid for including a finalization proof in a block.
    AmountFraction finalization_proof = 2;
    // Fraction paid for including each account creation transaction in a block.
    AmountFraction account_creation = 3;
    // Fraction paid for including an update transaction in a block.
    AmountFraction chain_update = 4;
  }
  message BakerStakeThresholdUpdatePayload {
    // Minimum threshold required for registering as a baker.
    Amount baker_stake_threshold = 1;
  }
  // Root updates are the highest kind of key updates. They can update every other set of keys,
  // even themselves. They can only be performed by Root level keys.
  message RootUpdatePayload {
    oneof update_type {
      HigherLevelKeys root_keys_update = 1;
      HigherLevelKeys level_1_keys_update = 2;
      AuthorizationsV0 level_2_keys_update_v0 = 3;
      AuthorizationsV1 level_2_keys_update_v1 = 4;
    }
  }
  // Level 1 updates are the intermediate update kind.
  // They can update themselves or level 2 keys. They can only be performed by level 1 keys.
  message Level1UpdatePayload {
    oneof update_type {
      HigherLevelKeys level_1_keys_update = 1;
      AuthorizationsV0 level_2_keys_update_v0 = 2;
      AuthorizationsV1 level_2_keys_update_v1 = 3;
    }
  }
  message CooldownParametersCpv1UpdatePayload {
    // Number of seconds that pool owners must cooldown
    // when reducing their equity capital or closing the pool.
    DurationSeconds pool_owner_cooldown = 1;
    // Number of seconds that a delegator must cooldown
    // when reducing their delegated stake.
    DurationSeconds delegator_cooldown = 2;
  }
  // Parameters related to staking pools.
  message PoolParametersCpv1UpdatePayload {
    // Fraction of finalization rewards charged by the passive delegation.
    AmountFraction passive_finalization_commission = 1;
    // Fraction of baking rewards charged by the passive delegation.
    AmountFraction passive_baking_commission = 2;
    // Fraction of transaction rewards charged by the L-pool.
    AmountFraction passive_transaction_commission = 3;
    // Bounds on the commission rates that may be charged by bakers.
    CommissionRanges commission_bounds = 4;
    // Minimum equity capital required for a new baker.
    Amount minimum_equity_capital = 5;
    // Maximum fraction of the total staked capital of that a new baker can
    // have.
    CapitalBound capital_bound = 6;
    // The maximum leverage that a baker can have as a ratio of total stake
    // to equity capital.
    LeverageFactor leverage_bound = 7;
  }
  // The time parameters are introduced as of protocol version 4, and consist of
  // the reward period length and the mint rate per payday. These are coupled as
  // a change to either affects the overall rate of minting.
  message TimeParametersCpv1UpdatePayload {
    RewardPeriodLength reward_period_length = 1;
    MintRate mint_per_payday = 2;
  }
  message MintDistributionCpv1UpdatePayload {
    AmountFraction baking_reward = 1;
    AmountFraction finalization_reward = 2;
  }

  oneof payload {
    ProtocolUpdatePayload protocol_update = 1;
    ElectionDifficulty election_difficulty_update = 2;
    ExchangeRate euro_per_energy_update = 3;
    ExchangeRate micro_ccd_per_euro_update = 4;
    AccountAddress foundation_account_update = 5;
    MintDistributionUpdatePayload mint_distribution_update = 6;
    TransactionFeeDistributionUpdatePayload transaction_fee_distribution_update = 7;
    GasRewardsUpdatePayload gas_rewards_update = 8;
    BakerStakeThresholdUpdatePayload baker_stake_threshold_update = 9;
    RootUpdatePayload root_update = 10;
    Level1UpdatePayload level_1_root_update = 11;
    ArInfo add_anonymity_revoker_update = 12;
    IpInfo add_identity_provider_update = 13;
    CooldownParametersCpv1UpdatePayload cooldown_parameters_cpv_1_update = 14;
    PoolParametersCpv1UpdatePayload pool_parameters_cpv_1_update = 15;
    TimeParametersCpv1UpdatePayload time_parameters_cpv_1_update = 16;
    MintDistributionCpv1UpdatePayload mint_distribution_cpv_1_update = 17;
  }
}

message AccountTransactionDetails {
  Amount cost = 1;
  AccountAddress sender = 2;
  AccountTransactionEffects effects = 3;
}

// Details of an account creation. These transactions are free, and we only
// ever get a response for them if the account is created, hence no failure
// cases.
message AccountCreationDetails {
  // Whether this is an initial or normal account.
  CredentialType credential_type = 1;
  // Address of the newly created account.
  AccountAddress address = 2;
  // Credential registration ID of the first credential.
  CredentialRegistrationId reg_id = 3;
}

// Transaction time specified as seconds since unix epoch.
message TransactionTime {
  uint64 value = 1;
}

// Details of an update instruction. These are free, and we only ever get a
// response for them if the update is successfully enqueued, hence no failure
// cases.
message UpdateDetails {
  TransactionTime effective_time = 1;
  UpdatePayload payload = 2;
}

message BlockItemSummary {
  message TransactionIndex {
    uint64 value = 1;
  }

  TransactionIndex index = 1;
  Energy energy_cost = 2;
  TransactionHash hash = 3;
  oneof details {
    AccountTransactionDetails account_transaction = 4;
    AccountCreationDetails account_creation = 5;
    UpdateDetails update = 6;
  }
}

enum UpdateType {
    UPDATE_PROTOCOL = 0;
    UPDATE_ELECTION_DIFFICULTY = 1;
    UPDATE_EURO_PER_ENERGY = 2;
    UPDATE_MICRO_GTU_PER_EURO = 3;
    UPDATE_FOUNDATION_ACCOUNT = 4;
    UPDATE_MINT_DISTRIBUTION = 5;
    UPDATE_TRANSACTION_FEE_DISTRIBUTION = 6;
    UPDATE_GAS_REWARDS = 7;
    UPDATE_POOL_PARAMETERS = 8;
    ADD_ANONYMITY_REVOKER = 9;
    ADD_IDENTITY_PROVIDER = 10;
    UPDATE_ROOT_KEYS = 11;
    UPDATE_LEVEL1_KEYS = 12;
    UPDATE_LEVEL2_KEYS = 13;
    UPDATE_COOLDOWN_PARAMETERS = 14;
    UPDATE_TIME_PARAMETERS = 15;
}

enum TransactionType {
  DEPLOY_MODULE = 0;
  INIT_CONTRACT = 1;
  UPDATE = 2;
  TRANSFER = 3;
  ADD_BAKER = 4;
  REMOVE_BAKER = 5;
  UPDATE_BAKER_STAKE = 6;
  UPDATE_BAKER_RESTAKE_EARNINGS = 7;
  UPDATE_BAKER_KEYS = 8;
  UPDATE_CREDENTIAL_KEYS = 9;
  ENCRYPTED_AMOUNT_TRANSFER = 10;
  TRANSFER_TO_ENCRYPTED = 11;
  TRANSFER_TO_PUBLIC = 12;
  TRANSFER_WITH_SCHEDULE = 13;
  UPDATE_CREDENTIALS = 14;
  REGISTER_DATA = 15;
  TRANSFER_WITH_MEMO = 16;
  ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO = 17;
  TRANSFER_WITH_SCHEDULE_AND_MEMO = 18;
  CONFIGURE_BAKER = 19;
  CONFIGURE_DELEGATION = 20;
}
