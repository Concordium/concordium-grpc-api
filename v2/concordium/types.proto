syntax = "proto3";

package concordium.v2;

// A message that contains no information.
message Empty {
}

/// Hash of a block. This is always 32 bytes long.
message BlockHash {
  bytes value = 1;
}

/// Hash of a transaction. This is always 32 bytes long.
message TransactionHash {
  bytes value = 1;
}

// The absolute height of a block.
message AbsoluteBlockHeight {
  uint64 value = 1;
}

// The height of a block relative to the last genesis.
message BlockHeight {
  uint64 value = 1;
}

// The ID of a baker, which is the index of its account.
message BakerId {
  uint64 value = 1;
}

// Index of the account in the account table. These are assigned sequentially
// in the order of creation of accounts. The first account has index 0.
message AccountIndex {
  uint64 value = 1;
}

// Reference (hash) of a smart contract module. This is always 32 bytes long.
message ModuleRef {
  bytes value = 1;
}

//! Source bytes of a smart contract module.
// ok test
message ModuleSource {
  bytes value = 1;
}

// An individual release of a locked balance.
message Release {
  // Effective time of the release in milliseconds since unix epoch.
  uint64 timestamp = 1;
  // Amount to be released.
  Amount amount = 2;
  // List of transaction hashes that contribute a balance to this release.
  repeated TransactionHash transactions = 3;
}

// State of the account's release schedule. This is the balance of the account
// that is owned by the account, but cannot be used until the release point.
message ReleaseSchedule {
  Amount total = 1;
  repeated Release schedules = 2;
}

// An encrypted amount, in two chunks in "little endian limbs". That is, the
// first chunk represents the low 32 bits of an amount, and the second chunk
// represents the high 32 bits. The chunks are serialized in order and
// represented as a byte array.
// Always 192 bytes.
message EncryptedAmount {
  bytes value = 1;
}

message EncryptedBalance {
  // Encrypted amount that is a result of this accounts' actions.
  // In particular this list includes the aggregate of
  //
  // - remaining amounts that result when transfering to public balance
  // - remaining amounts when transfering to another account
  // - encrypted amounts that are transferred from public balance
  //
  // When a transfer is made all of these must always be used.
  EncryptedAmount self_amount = 1;
  // Starting index for incoming encrypted amounts. If an aggregated amount
  // is present then this index is associated with such an amount and the
  // list of incoming encrypted amounts starts at the index `start_index
  // + 1`.
  uint64 start_index = 2;
  // If present, the amount that has resulted from aggregating other amounts
  // If this field is present so is `num_aggregated`.
  optional EncryptedAmount aggregated_amount = 3;
  // The number of aggregated amounts (must be at least 2 if present). This
  // field is present if and only if `aggregated_amount` is present.
  optional uint32 num_aggregated = 4;
  // Amounts starting at `start_index` (or at `start_index + 1` if there is
  // an aggregated amount present). They are assumed to be numbered
  // sequentially. The length of this list is bounded by the maximum number
  // of incoming amounts on the accounts, which is currently 32. After
  // that aggregation kicks in.
  repeated EncryptedAmount incoming_amounts = 5;
}

// Entity to which the account delegates a portion of its stake.
message DelegationTarget {
  oneof target {
    // Delegate passively, i.e., to no specific baker.
    Empty passive = 1;
    // Delegate to a specific baker.
    BakerId baker = 2;
  }
}

// Baker's public key used to check whether they won the lottery or not.
message BakerElectionVerifyKey {
  bytes value = 1;
}

// Baker's public key used to check that they are indeed the ones who
// produced the block.
message BakerSignatureVerifyKey {
  bytes value = 1;
}
 
// Baker's public key used to check signatures on finalization records.
// This is only used if the baker has sufficient stake to participate in
// finalization.
message BakerAggregationVerifyKey {
  bytes value = 1;
}

/// Information about a baker.
message BakerInfo {
  // Identity of the baker. This is actually the account index of
  // the account controlling the baker.
  BakerId baker_id = 1;
  // Baker's public key used to check whether they won the lottery or not.
  BakerElectionVerifyKey election_key = 2;
  // Baker's public key used to check that they are indeed the ones who
  // produced the block.
  BakerSignatureVerifyKey signature_key = 3;
  // Baker's public key used to check signatures on finalization records.
  // This is only used if the baker has sufficient stake to participate in
  // finalization.
  BakerAggregationVerifyKey aggregation_key = 4;
}

message StakePendingChange {
  message Reduce {
    Amount new_stake = 1;
    // Timestamp in milliseconds when the change takes effect.
    uint64 effective_time = 2;
  }
  
  oneof change {
    Reduce reduce = 1;
    // Remove the stake. The value is a timestamp of the effective time in
    // milliseconds.
    uint64 remove = 2;
  }
}

// Information about how open the pool is to new delegators.
enum OpenStatus {
  OPEN_STATUS_OPENFORALL = 0;
  OPEN_STATUS_CLOSEDFORNEW = 1;
  OPEN_STATUS_CLOSEDFORALL = 2;
}

// A fraction of an amount with a precision of `1/100_000`.
message AmountFraction {
  uint32 parts_per_hundred_thousand = 1;
}

// Distribution of the rewards for the particular pool.
message CommissionRates {
  // Fraction of finalization rewards charged by the pool owner.
  AmountFraction finalization = 1;
  // Fraction of baking rewards charged by the pool owner.
  AmountFraction baking = 2;
  // Fraction of transaction rewards charged by the pool owner.
  AmountFraction transaction = 3;
}

/// Additional information about a baking pool.
/// This information is added with the introduction of delegation.
message BakerPoolInfo {
  // Whether the pool allows delegators.
  OpenStatus open_status = 1;
  // The URL that links to the metadata about the pool.
  string url = 2;
  // The commission rates charged by the pool owner.
  CommissionRates commission_rates = 3;
}

// Information about the account stake, if the account is either a baker or a
// delegator.
message AccountStakingInfo {
  message Baker {
    Amount staked_amount = 1;
    bool restake_earnings = 2;
    BakerInfo baker_info = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
    // Present if the account is currently a baker, i.e., it is in the baking
    // committee of the current epoch.
    optional BakerPoolInfo pool_info = 5;
  }

  message Delegate {
    // The amount that the account delegates.
    Amount staked_amount = 1;
    // Whether the earnings are automatically added to the staked amount.
    bool restake_earnings = 2;
    // The entity to which the account delegates.
    DelegationTarget target = 3;
    // If present, any pending change to the delegated stake.
    optional StakePendingChange pending_change = 4;
  }

  oneof staking_info {
    // The account is a baker.
    Baker baker = 1;
    // The account is a delegator.
    Delegate delegate = 2;
  }
}

// A sequence number that determines the ordering of transactions from the
// account. The minimum sequence number is 1.
message Nonce {
  // The nonce
  uint64 value = 1;
}

// An amount of microCCD.
message Amount {
  uint64 value = 1;
}

// A credential index of an account.
message CredentialIndex {
  uint32 value = 1;
}

// The number of signatures required to sign.
message SignatureThreshold {
  uint32 value = 1;
}

// The number of credentials required to sign an account transaction.
message AccountThreshold {
  uint32 value = 1;
}

// An account encryption key. Always 96 bytes.
message EncryptionKey {
  bytes value = 1;
}

// An address of an account. Always 32 bytes.
message AccountAddress {
  bytes value = 1;
}

// An addrass is either a contract or account address.
message Address {
  oneof type {
    AccountAddress account = 1;
    ContractAddress contract = 2;
  }
}

// A public key used to verify transaction signatures from an account.
message AccountVerifyKey {
  oneof key {
    bytes ed25519_key = 1;
  }
}

// Public keys of a single credential.
message CredentialPublicKeys {
  map<uint32, AccountVerifyKey> keys = 1;
  SignatureThreshold threshold = 2;
}

// A registration ID of a credential, derived from the secred PRF key and a
// nonce. This is always 48 bytes long.
message CredentialRegistrationId {
  bytes value = 1;
}

// An index of the identity provider that identifies them uniquely in the
// context of a specific chain.
message IdentityProviderIdentity {
  uint32 value = 1;
}

// Representation of the pair of a year and month.
message YearMonth {
  uint32 year = 1;
  uint32 month = 2;
}

// Policy on a credential.
message Policy {
  // The year and month when the identity object from which the credential is
  // derived was created.
  YearMonth created_at = 1;
  // The last year and month when the credential is still valid. After this
  // expires an account can no longer be created from the credential.
  YearMonth valid_to = 2;
  // Mapping from attribute tags to attribute values. Attribute tags are always
  // representable in a single `u8`, attribute values are never more than 31
  // bytes in length.
  map<uint32, bytes> attributes = 3;
}

// Values contained in an initial credential.
message InitialCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
}

/// Data relating to a single anonymity revoker sent by the account holder to
/// the chain.
message ChainArData {
  // Share of the encryption of IdCredPub.
  bytes enc_id_cred_pub_share = 1;
}

// The number of anonymity revokers needed to revoke anonymity of a credential
// holder.
message ArThreshold {
  uint32 value = 1;
}

// A single commitment in the G1 group of the BLS curve.
message Commitment {
  bytes value = 1;
}

// Commitments that are part of a normal credential.
message CredentialCommitments {
  // Commitment to the PRF key.
  Commitment prf = 1;
  // Commitment to the counter used to generate the credential registration id.
  Commitment cred_counter = 2;
  // Commitment to the `max_accounts` value, which determines the maximum number
  // of credentials that may be created from the identity object.
  Commitment max_accounts = 3;
  // Commitments to the attributes which have not been revealed in the policy.
  map<uint32, Commitment> attributes = 4;
  // List of commitments to the coefficients of the sharing polynomial. This
  // polynomial is used in a shared encryption of `id_cred_pub` among the
  // anonymity revokers.
  repeated Commitment id_cred_sec_sharing_coeff = 5;
}

// Values contained in a normal (non-initial) credential.
message NormalCredentialValues {
  // Public keys of the credential.
  CredentialPublicKeys keys = 1;
  // Its registration ID.
  CredentialRegistrationId cred_id = 2;
  // The identity provider who signed the identity object from which this
  // credential is derived.
  IdentityProviderIdentity ip_id = 3;
  // Policy of this credential.
  Policy policy = 4;
  // The number of anonymity revokers that must work together to revoke the
  // anonymity of the credential holder.
  ArThreshold ar_threshold = 5;
  // Mapping from anonymity revoker identities to revocation data for the given anonymity revoker.
  map<uint32, ChainArData> ar_data = 6;
  // Commitments to attributes which have not been revealed.
  CredentialCommitments commitments = 7;
}

message AccountCredential {
  oneof credential_values {
    InitialCredentialValues initial = 1;
    NormalCredentialValues normal = 2;
  }
}

message CredentialType {
  oneof type {
    Empty initial = 1;
    Empty normal = 2;
  }
}

message AccountInfo {
  // Next sequence number to be used for transactions signed from this account.
  Nonce nonce = 1;
  // Current (unencrypted) balance of the account.
  Amount amount = 2;
  // Release schedule for any locked up amount. This could be an empty
  // release schedule.
  ReleaseSchedule schedule = 3;
  // Map of all currently active credentials on the account.
  // This includes public keys that can sign for the given credentials, as
  // well as any revealed attributes. This map always contains a credential
  // with index 0.
  map<uint32, AccountCredential> creds = 4;
  // Lower bound on how many credentials must sign any given transaction from
  // this account.
  AccountThreshold threshold = 5;
  // The encrypted balance of the account.
  EncryptedBalance encrypted_balance = 6;
  // The public key for sending encrypted balances to the account.
  EncryptionKey encryption_key = 7;
  // Internal index of the account. Accounts on the chain get sequential
  // indices. These should generally not be used outside of the chain,
  // the account address is meant to be used to refer to accounts,
  // however the account index serves the role of the baker id, if the
  // account is a baker. Hence it is exposed here as well.
  AccountIndex index = 8;
  // Present if the account is a baker or delegator. In that case
  // it is the information about the baker or delegator.
  optional AccountStakingInfo stake = 9;
  // Canonical address of the account. This is derived from the first credential
  // that created the account.
  AccountAddress address = 10;
}

message BlockHashInput {
  oneof block_hash_input {
    Empty best = 1;
    Empty last_final = 2;
    BlockHash given = 3;
  }
}

message AccountInfoRequest {
  BlockHashInput block_hash = 1;
  oneof account_identifier {
    AccountAddress address = 2;
    CredentialRegistrationId cred_id = 3;
    AccountIndex account_index = 4;
  }
}

// Information about a finalized block that is part of the streaming response.
message FinalizedBlockInfo {
  // Hash of the block.
  BlockHash hash = 1;
  // Absolute height of the block, height 0 is the genesis block.
  AbsoluteBlockHeight height = 2;
}

// Request the ancestors for the given block.
message AncestorsRequest {
  // The block to get ancestors of.
  BlockHashInput block_hash = 1;
  // The maximum number of ancestors returned.
  uint64 amount = 2;
}

// Request for getting the source of a smart contract module.
message ModuleSourceRequest {
  // The block to be used for the query.
  BlockHashInput block_hash = 1;

  // The reference (hash) of the module.
  ModuleRef module_ref = 2;
}

// Address of a smart contract instance.
message ContractAddress {
  // The index of the smart contract.
  uint64 index = 1;
  // The subindex of the smart contract instance.
  // Currently not used, so it is always 0.
  uint64 subindex = 2;
}

message InstanceInfoRequest {
  BlockHashInput block_hash = 1;
  ContractAddress address = 2;
}

// Information about a smart contract instance.
message InstanceInfo {

  message V0 {
    ContractState model = 1;
    AccountAddress owner = 2;
    Amount amount = 3;
    repeated ReceiveName methods = 4;
    InitName name = 5;
    ModuleRef source_module = 6;
  }

  message V1 {
    AccountAddress owner = 2;
    Amount amount = 3;
    repeated ReceiveName methods = 4;
    InitName name = 5;
    ModuleRef source_module = 6;
  }

  oneof version {
    V0 v0 = 1;
    V1 v1 = 2;
  }
}

message ReceiveName {
  string value = 1;
}

message InitName {
  string value = 1;
}

// Parameter to a smart contract invocation.
message Parameter {
  bytes value = 1;
}

message ContractState {
  bytes value = 1;
}

message TransactionStatus {

  message Committed {
    repeated TransactionSummaryInBlock outcomes = 1;
  }

  message Finalized {
    TransactionSummaryInBlock outcome = 1; // TODO: internalservererror grpc error if there are multiple
  }

  oneof status {
    Empty received = 1;
    Committed committed = 2;
    Finalized finalized = 3;
  }
}

message TransactionSummaryInBlock {
  BlockHash block_hash = 1;
  BlockItemSummary outcome = 2; // TODO: Just a technical maybe in hs. No maybe in grpc.
}

message Energy {
  uint64 value = 1;
}

message RejectReason {

  message ModuleHashAlreadyExists {
    ModuleRef contents = 1;
  }

  message InvalidAccountReference {
    AccountAddress contents = 1;
  }

  message InvalidInitMethod {
    ModuleRef module_ref = 1;
    InitName init_name = 2;
  }

  message InvalidReceiveMethod {
    ModuleRef module_ref = 1;
    ReceiveName receive_name = 2;
  }

  message InvalidModuleReference {
    ModuleRef contents = 1;
  }

  message InvalidContractAddress {
    ContractAddress contents = 1;
  }

  message AmountTooLarge {
    Address address = 1;
    Amount amount = 2;
  }

  message RejectedInit {
    int32 reject_reason = 1;
  }

  message RejectedReceive {
    int32 reject_reason = 1;
    ContractAddress contract_address = 2;
    ReceiveName receive_name = 3;
    Parameter parameter = 4;
  }

  message AlreadyABaker {
    BakerId contents = 1;
  }

  message NotABaker {
    AccountAddress contents = 1;
  }

  message DuplicateAggregationKey {
    BakerAggregationVerifyKey contents = 1;
  }

  message EncryptedAmountSelfTransfer {
    AccountAddress contents = 1;
  }

  message ScheduledSelfTransfer {
    AccountAddress contents = 1;
  }

  message DuplicateCredIds {
    repeated CredentialRegistrationId contents = 1;
  }

  message NonExistentCredIds {
    repeated CredentialRegistrationId contents = 1;
  }

  message NotADelegator {
    AccountAddress contents = 1;
  }

  message DelegationTargetNotABaker {
    BakerId contents = 1;
  }

  oneof reason {
    // Raised while validating a Wasm module that is not well formed.
    Empty module_not_wf = 1;
    // The smart contract module hash already exists.
    ModuleHashAlreadyExists module_hash_already_exists = 2;
    // Account does not exist.
    InvalidAccountReference invalid_account_reference = 3;
    // Reference to a non-existing contract init method.
    InvalidInitMethod invalid_init_method = 4;
    // Reference to a non-existing contract receive method.
    InvalidReceiveMethod invalid_receive_method = 5;
    // Reference to a non-existing smart contract module.
    InvalidModuleReference invalid_module_reference = 6;
    // Contract instance does not exist.
    InvalidContractAddress invalid_contract_address = 7;
    /// Runtime exception occurred when running either the init or receive
    /// method.
    Empty runtime_failure = 8;
    /// When one wishes to transfer an amount from A to B but there
    /// are not enough funds on account/contract A to make this
    /// possible. The data are the from address and the amount to transfer.
    AmountTooLarge amount_too_large = 9;
    /// Serialization of the body failed.
    Empty serialization_failure = 10;
    /// We ran of out energy to process this transaction.
    Empty out_of_energy = 11;
    /// Rejected due to contract logic in init function of a contract.
    RejectedInit rejected_init = 12;
    /// Rejected due to contract logic in receive function of a contract.
    RejectedReceive rejected_receive = 13;
    /// Proof that the baker owns relevant private keys is not valid.
    Empty invalid_proof = 14;
    /// Tried to add baker for an account that already has a baker
    AlreadyABaker already_a_baker = 15;
    /// Tried to remove a baker for an account that has no baker
    NotABaker not_a_baker = 16;
    /// The amount on the account was insufficient to cover the proposed stake
    Empty insufficient_balance_for_baker_stake = 17;
    /// The amount provided is under the threshold required for becoming a baker
    Empty stake_under_minimum_threshold_for_baking = 18;
    /// The change could not be made because the baker is in cooldown for
    /// another change
    Empty baker_in_cooldown = 19;
    /// A baker with the given aggregation key already exists
    DuplicateAggregationKey duplicate_aggregation_key = 20;
    /// Encountered credential ID that does not exist
    Empty non_existent_credential_id = 21;
    /// Attempted to add an account key to a key index already in use
    Empty key_index_already_in_use = 22;
    /// When the account threshold is updated, it must not exceed the amount of
    /// existing keys
    Empty invalid_account_threshold = 23;
    /// When the credential key threshold is updated, it must not exceed the
    /// amount of existing keys
    Empty invalid_credential_key_sign_threshold = 24;
    /// Proof for an encrypted amount transfer did not validate.
    Empty invalid_encrypted_amount_transfer_proof = 25;
    /// Proof for a secret to public transfer did not validate.
    Empty invalid_transfer_to_public_proof = 26;
    /// Account tried to transfer an encrypted amount to itself, that's not
    /// allowed.
    EncryptedAmountSelfTransfer encrypted_amount_self_transfer = 27;
    /// The provided index is below the start index or above `startIndex +
    /// length incomingAmounts`
    Empty invalid_index_on_encrypted_transfer = 28;
    /// The transfer with schedule is going to send 0 tokens
    Empty zero_scheduledAmount = 29;
    /// The transfer with schedule has a non strictly increasing schedule
    Empty non_increasing_schedule = 30;
    /// The first scheduled release in a transfer with schedule has already
    /// expired
    Empty first_scheduled_release_expired = 31;
    /// Account tried to transfer with schedule to itself, that's not allowed.
    ScheduledSelfTransfer scheduled_self_transfer = 32;
    /// At least one of the credentials was either malformed or its proof was
    /// incorrect.
    Empty invalid_credentials = 33;
    /// Some of the credential IDs already exist or are duplicated in the
    /// transaction.
    DuplicateCredIds duplicate_cred_ids = 34;
    /// A credential id that was to be removed is not part of the account.
    NonExistentCredIds non_existent_cred_ids = 35;
    /// Attemp to remove the first credential
    Empty remove_first_credential = 36;
    /// The credential holder of the keys to be updated did not sign the
    /// transaction
    Empty credential_holder_did_not_sign = 37;
    /// Account is not allowed to have multiple credentials because it contains
    /// a non-zero encrypted transfer.
    Empty not_allowed_multiple_credentials = 38;
    /// The account is not allowed to receive encrypted transfers because it has
    /// multiple credentials.
    Empty not_allowed_to_receive_encrypted = 39;
    /// The account is not allowed to send encrypted transfers (or transfer
    /// from/to public to/from encrypted)
    Empty not_allowed_to_handle_encrypted = 40;
    /// A configure baker transaction is missing one or more arguments in order
    /// to add a baker.
    Empty missing_baker_add_parameters = 41;
    /// Finalization reward commission is not in the valid range for a baker
    Empty finalization_reward_commission_not_in_range = 42;
    /// Baking reward commission is not in the valid range for a baker
    Empty baking_reward_commission_not_in_range = 43;
    /// Transaction fee commission is not in the valid range for a baker
    Empty transaction_fee_commission_not_in_range = 44;
    /// Tried to add baker for an account that already has a delegator.
    Empty already_a_delegator = 45;
    /// The amount on the account was insufficient to cover the proposed stake.
    Empty insufficient_balance_for_delegation_stake = 46;
    /// A configure delegation transaction is missing one or more arguments in
    /// order to add a delegator.
    Empty missing_delegation_add_parameters = 47;
    /// Delegation stake when adding a delegator was 0.
    Empty insufficient_delegation_stake = 48;
    /// Account is not a delegation account.
    Empty delegator_in_cooldown = 49;
    /// Account is not a delegation account.
    NotADelegator not_a_delegator = 50;
    /// Delegation target is not a baker
    DelegationTargetNotABaker delegation_target_not_a_baker = 51;
    /// The amount would result in pool capital higher than the maximum
    /// threshold.
    Empty stake_over_maximum_threshold_for_pool = 52;
    /// The amount would result in pool with a too high fraction of delegated
    /// capital.
    Empty pool_would_become_over_delegated = 53;
    /// The pool is not open to delegators.
    Empty pool_closed = 54;
  }
}

message AccountTransactionEffects {
  message None {
    // Transaction type of a failed transaction, if known.
    // In case of serialization failure this will not be set.
    optional TransactionType transaction_type = 1;
    // Reason for rejection of the transaction.
    RejectReason reject_reason = 2;
  }
  message AccountTransfer {
    Amount amount = 1;
    AccountAddress to_ = 2;
  }

  oneof effect {
    None none = 1;
    AccountTransfer account_transfer = 2; // TODO: implement the rest.
  }
}

message AccountTransactionDetails {
  Amount cost = 1;
  AccountAddress sender = 2;
  AccountTransactionEffects effects = 3;
}

message BlockItemSummary {
  message TransactionIndex {
    uint64 value = 1;
  }

  TransactionIndex index = 1;
  Energy energy_cost = 2;
  TransactionHash hash = 3;
  oneof details {
    AccountTransactionDetails account_transaction = 4;
    // account_creation
    // update
  }
}



// TODO: Consider if microgtu/euro should be the default value, as it will be used much more frequently.
// First variant of an enum will be encoded with no bytes.
enum UpdateType {
    UPDATE_PROTOCOL = 0;
    UPDATE_ELECTION_DIFFICULTY = 1;
    UPDATE_EURO_PER_ENERGY = 2;
    UPDATE_MICRO_GTU_PER_EURO = 3;
    UPDATE_FOUNDATION_ACCOUNT = 4;
    UPDATE_MINT_DISTRIBUTION = 5;
    UPDATE_TRANSACTION_FEE_DISTRIBUTION = 6;
    UPDATE_GAS_REWARDS = 7;
    UPDATE_POOL_PARAMETERS = 8;
    ADD_ANONYMITY_REVOKER = 9;
    ADD_IDENTITY_PROVIDER = 10;
    UPDATE_ROOT_KEYS = 11;
    UPDATE_LEVEL1_KEYS = 12;
    UPDATE_LEVEL2_KEYS = 13;
    UPDATE_COOLDOWN_PARAMETERS = 14;
    UPDATE_TIME_PARAMETERS = 15;
}

enum TransactionType {
  DEPLOY_MODULE = 0;
  INIT_CONTRACT = 1;
  UPDATE = 2;
  TRANSFER = 3;
  ADD_BAKER = 4;
  REMOVE_BAKER = 5;
  UPDATE_BAKER_STAKE = 6;
  UPDATE_BAKER_RESTAKE_EARNINGS = 7;
  UPDATE_BAKER_KEYS = 8;
  UPDATE_CREDENTIAL_KEYS = 9;
  ENCRYPTED_AMOUNT_TRANSFER = 10;
  TRANSFER_TO_ENCRYPTED = 11;
  TRANSFER_TO_PUBLIC = 12;
  TRANSFER_WITH_SCHEDULE = 13;
  UPDATE_CREDENTIALS = 14;
  REGISTER_DATA = 15;
  TRANSFER_WITH_MEMO = 16;
  ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO = 17;
  TRANSFER_WITH_SCHEDULE_AND_MEMO = 18;
  CONFIGURE_BAKER = 19;
  CONFIGURE_DELEGATION = 20;
}
